{"ast":null,"code":"/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst POW_2_256 = _2n ** BigInt(256);\nconst CURVE = {\n  a: _0n,\n  b: BigInt(7),\n  P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),\n  n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),\n  h: _1n,\n  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')\n};\nexport { CURVE };\nfunction weistrass(x) {\n  const {\n    a,\n    b\n  } = CURVE;\n  const x2 = mod(x * x);\n  const x3 = mod(x2 * x);\n  return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass JacobianPoint {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  static fromAffine(p) {\n    if (!(p instanceof Point)) {\n      throw new TypeError('JacobianPoint#fromAffine: expected Point');\n    }\n    return new JacobianPoint(p.x, p.y, _1n);\n  }\n  static toAffineBatch(points) {\n    const toInv = invertBatch(points.map(p => p.z));\n    return points.map((p, i) => p.toAffine(toInv[i]));\n  }\n  static normalizeZ(points) {\n    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n  }\n  equals(other) {\n    if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    const Z1Z1 = mod(Z1 ** _2n);\n    const Z2Z2 = mod(Z2 ** _2n);\n    const U1 = mod(X1 * Z2Z2);\n    const U2 = mod(X2 * Z1Z1);\n    const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n    const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n    return U1 === U2 && S1 === S2;\n  }\n  negate() {\n    return new JacobianPoint(this.x, mod(-this.y), this.z);\n  }\n  double() {\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const A = mod(X1 ** _2n);\n    const B = mod(Y1 ** _2n);\n    const C = mod(B ** _2n);\n    const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));\n    const E = mod(_3n * A);\n    const F = mod(E ** _2n);\n    const X3 = mod(F - _2n * D);\n    const Y3 = mod(E * (D - X3) - _8n * C);\n    const Z3 = mod(_2n * Y1 * Z1);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n  add(other) {\n    if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    if (X2 === _0n || Y2 === _0n) return this;\n    if (X1 === _0n || Y1 === _0n) return other;\n    const Z1Z1 = mod(Z1 ** _2n);\n    const Z2Z2 = mod(Z2 ** _2n);\n    const U1 = mod(X1 * Z2Z2);\n    const U2 = mod(X2 * Z1Z1);\n    const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n    const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n    const H = mod(U2 - U1);\n    const r = mod(S2 - S1);\n    if (H === _0n) {\n      if (r === _0n) {\n        return this.double();\n      } else {\n        return JacobianPoint.ZERO;\n      }\n    }\n    const HH = mod(H ** _2n);\n    const HHH = mod(H * HH);\n    const V = mod(U1 * HH);\n    const X3 = mod(r ** _2n - HHH - _2n * V);\n    const Y3 = mod(r * (V - X3) - S1 * HHH);\n    const Z3 = mod(Z1 * Z2 * H);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n  subtract(other) {\n    return this.add(other.negate());\n  }\n  multiplyUnsafe(scalar) {\n    const P0 = JacobianPoint.ZERO;\n    if (typeof scalar === 'bigint' && scalar === _0n) return P0;\n    let n = normalizeScalar(scalar);\n    if (n === _1n) return this;\n    if (!USE_ENDOMORPHISM) {\n      let p = P0;\n      let d = this;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    }\n    let {\n      k1neg,\n      k1,\n      k2neg,\n      k2\n    } = splitScalarEndo(n);\n    let k1p = P0;\n    let k2p = P0;\n    let d = this;\n    while (k1 > _0n || k2 > _0n) {\n      if (k1 & _1n) k1p = k1p.add(d);\n      if (k2 & _1n) k2p = k2p.add(d);\n      d = d.double();\n      k1 >>= _1n;\n      k2 >>= _1n;\n    }\n    if (k1neg) k1p = k1p.negate();\n    if (k2neg) k2p = k2p.negate();\n    k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n    return k1p.add(k2p);\n  }\n  precomputeWindow(W) {\n    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n    const points = [];\n    let p = this;\n    let base = p;\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n      for (let i = 1; i < 2 ** (W - 1); i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n      p = base.double();\n    }\n    return points;\n  }\n  wNAF(n, affinePoint) {\n    if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n    if (256 % W) {\n      throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n    }\n    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n    if (!precomputes) {\n      precomputes = this.precomputeWindow(W);\n      if (affinePoint && W !== 1) {\n        precomputes = JacobianPoint.normalizeZ(precomputes);\n        pointPrecomputes.set(affinePoint, precomputes);\n      }\n    }\n    let p = JacobianPoint.ZERO;\n    let f = JacobianPoint.ZERO;\n    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n    const windowSize = 2 ** (W - 1);\n    const mask = BigInt(2 ** W - 1);\n    const maxNumber = 2 ** W;\n    const shiftBy = BigInt(W);\n    for (let window = 0; window < windows; window++) {\n      const offset = window * windowSize;\n      let wbits = Number(n & mask);\n      n >>= shiftBy;\n      if (wbits > windowSize) {\n        wbits -= maxNumber;\n        n += _1n;\n      }\n      if (wbits === 0) {\n        let pr = precomputes[offset];\n        if (window % 2) pr = pr.negate();\n        f = f.add(pr);\n      } else {\n        let cached = precomputes[offset + Math.abs(wbits) - 1];\n        if (wbits < 0) cached = cached.negate();\n        p = p.add(cached);\n      }\n    }\n    return {\n      p,\n      f\n    };\n  }\n  multiply(scalar, affinePoint) {\n    let n = normalizeScalar(scalar);\n    let point;\n    let fake;\n    if (USE_ENDOMORPHISM) {\n      const {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n      } = splitScalarEndo(n);\n      let {\n        p: k1p,\n        f: f1p\n      } = this.wNAF(k1, affinePoint);\n      let {\n        p: k2p,\n        f: f2p\n      } = this.wNAF(k2, affinePoint);\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n      point = k1p.add(k2p);\n      fake = f1p.add(f2p);\n    } else {\n      const {\n        p,\n        f\n      } = this.wNAF(n, affinePoint);\n      point = p;\n      fake = f;\n    }\n    return JacobianPoint.normalizeZ([point, fake])[0];\n  }\n  toAffine() {\n    let invZ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : invert(this.z);\n    const {\n      x,\n      y,\n      z\n    } = this;\n    const iz1 = invZ;\n    const iz2 = mod(iz1 * iz1);\n    const iz3 = mod(iz2 * iz1);\n    const ax = mod(x * iz2);\n    const ay = mod(y * iz3);\n    const zz = mod(z * iz1);\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return new Point(ax, ay);\n  }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  _setWindowSize(windowSize) {\n    this._WINDOW_SIZE = windowSize;\n    pointPrecomputes.delete(this);\n  }\n  static fromCompressedHex(bytes) {\n    const isShort = bytes.length === 32;\n    const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n    if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n    const y2 = weistrass(x);\n    let y = sqrtMod(y2);\n    const isYOdd = (y & _1n) === _1n;\n    if (isShort) {\n      if (isYOdd) y = mod(-y);\n    } else {\n      const isFirstByteOdd = (bytes[0] & 1) === 1;\n      if (isFirstByteOdd !== isYOdd) y = mod(-y);\n    }\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n  static fromUncompressedHex(bytes) {\n    const x = bytesToNumber(bytes.subarray(1, 33));\n    const y = bytesToNumber(bytes.subarray(33, 65));\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n    const len = bytes.length;\n    const header = bytes[0];\n    if (len === 32 || len === 33 && (header === 0x02 || header === 0x03)) {\n      return this.fromCompressedHex(bytes);\n    }\n    if (len === 65 && header === 0x04) return this.fromUncompressedHex(bytes);\n    throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);\n  }\n  static fromPrivateKey(privateKey) {\n    return Point.BASE.multiply(normalizePrivateKey(privateKey));\n  }\n  static fromSignature(msgHash, signature, recovery) {\n    msgHash = ensureBytes(msgHash);\n    const h = truncateHash(msgHash);\n    const {\n      r,\n      s\n    } = normalizeSignature(signature);\n    if (recovery !== 0 && recovery !== 1) {\n      throw new Error('Cannot recover signature: invalid recovery bit');\n    }\n    const prefix = recovery & 1 ? '03' : '02';\n    const R = Point.fromHex(prefix + numTo32bStr(r));\n    const {\n      n\n    } = CURVE;\n    const rinv = invert(r, n);\n    const u1 = mod(-h * rinv, n);\n    const u2 = mod(s * rinv, n);\n    const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n    if (!Q) throw new Error('Cannot recover signature: point at infinify');\n    Q.assertValidity();\n    return Q;\n  }\n  toRawBytes() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return hexToBytes(this.toHex(isCompressed));\n  }\n  toHex() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const x = numTo32bStr(this.x);\n    if (isCompressed) {\n      const prefix = this.y & _1n ? '03' : '02';\n      return `${prefix}${x}`;\n    } else {\n      return `04${x}${numTo32bStr(this.y)}`;\n    }\n  }\n  toHexX() {\n    return this.toHex(true).slice(2);\n  }\n  toRawX() {\n    return this.toRawBytes(true).slice(1);\n  }\n  assertValidity() {\n    const msg = 'Point is not on elliptic curve';\n    const {\n      x,\n      y\n    } = this;\n    if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n    const left = mod(y * y);\n    const right = weistrass(x);\n    if (mod(left - right) !== _0n) throw new Error(msg);\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n  negate() {\n    return new Point(this.x, mod(-this.y));\n  }\n  double() {\n    return JacobianPoint.fromAffine(this).double().toAffine();\n  }\n  add(other) {\n    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n  }\n  subtract(other) {\n    return this.add(other.negate());\n  }\n  multiply(scalar) {\n    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n  }\n  multiplyAndAddUnsafe(Q, a, b) {\n    const P = JacobianPoint.fromAffine(this);\n    const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n    const sum = aP.add(bQ);\n    return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n  }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n  if (data.length < 2 || data[0] !== 0x02) {\n    throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n  }\n  const len = data[1];\n  const res = data.subarray(2, len + 2);\n  if (!len || res.length !== len) {\n    throw new Error(`Invalid signature integer: wrong length`);\n  }\n  if (res[0] === 0x00 && res[1] <= 0x7f) {\n    throw new Error('Invalid signature integer: trailing length');\n  }\n  return {\n    data: bytesToNumber(res),\n    left: data.subarray(len + 2)\n  };\n}\nfunction parseDERSignature(data) {\n  if (data.length < 2 || data[0] != 0x30) {\n    throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n  }\n  if (data[1] !== data.length - 2) {\n    throw new Error('Invalid signature: incorrect length');\n  }\n  const {\n    data: r,\n    left: sBytes\n  } = parseDERInt(data.subarray(2));\n  const {\n    data: s,\n    left: rBytesLeft\n  } = parseDERInt(sBytes);\n  if (rBytesLeft.length) {\n    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n  }\n  return {\n    r,\n    s\n  };\n}\nexport class Signature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  static fromCompact(hex) {\n    const arr = isUint8a(hex);\n    const name = 'Signature.fromCompact';\n    if (typeof hex !== 'string' && !arr) throw new TypeError(`${name}: Expected string or Uint8Array`);\n    const str = arr ? bytesToHex(hex) : hex;\n    if (str.length !== 128) throw new Error(`${name}: Expected 64-byte hex`);\n    return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n  }\n  static fromDER(hex) {\n    const arr = isUint8a(hex);\n    if (typeof hex !== 'string' && !arr) throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n    const {\n      r,\n      s\n    } = parseDERSignature(arr ? hex : hexToBytes(hex));\n    return new Signature(r, s);\n  }\n  static fromHex(hex) {\n    return this.fromDER(hex);\n  }\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');\n    if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');\n  }\n  hasHighS() {\n    const HALF = CURVE.n >> _1n;\n    return this.s > HALF;\n  }\n  normalizeS() {\n    return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n  }\n  toDERRawBytes() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return hexToBytes(this.toDERHex(isCompressed));\n  }\n  toDERHex() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const sHex = sliceDER(numberToHexUnpadded(this.s));\n    if (isCompressed) return sHex;\n    const rHex = sliceDER(numberToHexUnpadded(this.r));\n    const rLen = numberToHexUnpadded(rHex.length / 2);\n    const sLen = numberToHexUnpadded(sHex.length / 2);\n    const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n    return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n  }\n  toRawBytes() {\n    return this.toDERRawBytes();\n  }\n  toHex() {\n    return this.toDERHex();\n  }\n  toCompactRawBytes() {\n    return hexToBytes(this.toCompactHex());\n  }\n  toCompactHex() {\n    return numTo32bStr(this.r) + numTo32bStr(this.s);\n  }\n}\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n  if (!arrays.every(isUint8a)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nfunction isUint8a(bytes) {\n  return bytes instanceof Uint8Array;\n}\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  let hex = '';\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\nfunction numTo32bStr(num) {\n  if (num > POW_2_256) throw new Error('Expected number < 2^256');\n  return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n  return hexToBytes(numTo32bStr(num));\n}\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n  return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\nfunction bytesToNumber(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n  if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n  if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;\n  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n  const {\n    P\n  } = CURVE;\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n  return res;\n}\nfunction sqrtMod(x) {\n  const {\n    P\n  } = CURVE;\n  const _6n = BigInt(6);\n  const _11n = BigInt(11);\n  const _22n = BigInt(22);\n  const _23n = BigInt(23);\n  const _44n = BigInt(44);\n  const _88n = BigInt(88);\n  const b2 = x * x * x % P;\n  const b3 = b2 * b2 * x % P;\n  const b6 = pow2(b3, _3n) * b3 % P;\n  const b9 = pow2(b6, _3n) * b3 % P;\n  const b11 = pow2(b9, _2n) * b2 % P;\n  const b22 = pow2(b11, _11n) * b11 % P;\n  const b44 = pow2(b22, _22n) * b22 % P;\n  const b88 = pow2(b44, _44n) * b44 % P;\n  const b176 = pow2(b88, _88n) * b88 % P;\n  const b220 = pow2(b176, _44n) * b44 % P;\n  const b223 = pow2(b220, _3n) * b3 % P;\n  const t1 = pow2(b223, _23n) * b22 % P;\n  const t2 = pow2(t1, _6n) * b2 % P;\n  return pow2(t2, _2n);\n}\nfunction invert(number) {\n  let modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  let a = mod(number, modulo);\n  let b = modulo;\n  let x = _0n,\n    y = _1n,\n    u = _1n,\n    v = _0n;\n  while (a !== _0n) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\nfunction invertBatch(nums) {\n  let p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const scratch = new Array(nums.length);\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (num === _0n) return acc;\n    scratch[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  const inverted = invert(lastMultiplied, p);\n  nums.reduceRight((acc, num, i) => {\n    if (num === _0n) return acc;\n    scratch[i] = mod(acc * scratch[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return scratch;\n}\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst POW_2_128 = _2n ** BigInt(128);\nfunction splitScalarEndo(k) {\n  const {\n    n\n  } = CURVE;\n  const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n  const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n  const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n  const b2 = a1;\n  const c1 = divNearest(b2 * k, n);\n  const c2 = divNearest(-b1 * k, n);\n  let k1 = mod(k - c1 * a1 - c2 * a2, n);\n  let k2 = mod(-c1 * b1 - c2 * b2, n);\n  const k1neg = k1 > POW_2_128;\n  const k2neg = k2 > POW_2_128;\n  if (k1neg) k1 = n - k1;\n  if (k2neg) k2 = n - k2;\n  if (k1 > POW_2_128 || k2 > POW_2_128) {\n    throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n  }\n  return {\n    k1neg,\n    k1,\n    k2neg,\n    k2\n  };\n}\nfunction truncateHash(hash) {\n  const {\n    n\n  } = CURVE;\n  const byteLength = hash.length;\n  const delta = byteLength * 8 - 256;\n  let h = bytesToNumber(hash);\n  if (delta > 0) h = h >> BigInt(delta);\n  if (h >= n) h -= n;\n  return h;\n}\nclass HmacDrbg {\n  constructor() {\n    this.v = new Uint8Array(32).fill(1);\n    this.k = new Uint8Array(32).fill(0);\n    this.counter = 0;\n  }\n  hmac() {\n    for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      values[_key2] = arguments[_key2];\n    }\n    return utils.hmacSha256(this.k, ...values);\n  }\n  hmacSync() {\n    if (typeof utils.hmacSha256Sync !== 'function') throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n    for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      values[_key3] = arguments[_key3];\n    }\n    const res = utils.hmacSha256Sync(this.k, ...values);\n    if (res instanceof Promise) throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n    return res;\n  }\n  incr() {\n    if (this.counter >= 1000) {\n      throw new Error('Tried 1,000 k values for sign(), all were invalid');\n    }\n    this.counter += 1;\n  }\n  async reseed() {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n    this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n    this.v = await this.hmac(this.v);\n    if (seed.length === 0) return;\n    this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n    this.v = await this.hmac(this.v);\n  }\n  reseedSync() {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n    this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n    this.v = this.hmacSync(this.v);\n    if (seed.length === 0) return;\n    this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n    this.v = this.hmacSync(this.v);\n  }\n  async generate() {\n    this.incr();\n    this.v = await this.hmac(this.v);\n    return this.v;\n  }\n  generateSync() {\n    this.incr();\n    this.v = this.hmacSync(this.v);\n    return this.v;\n  }\n}\nfunction isWithinCurveOrder(num) {\n  return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n  return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n  const k = bytesToNumber(kBytes);\n  if (!isWithinCurveOrder(k)) return;\n  const {\n    n\n  } = CURVE;\n  const q = Point.BASE.multiply(k);\n  const r = mod(q.x, n);\n  if (r === _0n) return;\n  const s = mod(invert(k, n) * mod(m + d * r, n), n);\n  if (s === _0n) return;\n  const sig = new Signature(r, s);\n  const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n  return {\n    sig,\n    recovery\n  };\n}\nfunction normalizePrivateKey(key) {\n  let num;\n  if (typeof key === 'bigint') {\n    num = key;\n  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n  } else if (typeof key === 'string') {\n    if (key.length !== 64) throw new Error('Expected 32 bytes of private key');\n    num = hexToNumber(key);\n  } else if (isUint8a(key)) {\n    if (key.length !== 32) throw new Error('Expected 32 bytes of private key');\n    num = bytesToNumber(key);\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');\n  return num;\n}\nfunction normalizePublicKey(publicKey) {\n  if (publicKey instanceof Point) {\n    publicKey.assertValidity();\n    return publicKey;\n  } else {\n    return Point.fromHex(publicKey);\n  }\n}\nfunction normalizeSignature(signature) {\n  if (signature instanceof Signature) {\n    signature.assertValidity();\n    return signature;\n  }\n  try {\n    return Signature.fromDER(signature);\n  } catch (error) {\n    return Signature.fromCompact(signature);\n  }\n}\nexport function getPublicKey(privateKey) {\n  let isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery) {\n  let isCompressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isPub(item) {\n  const arr = isUint8a(item);\n  const str = typeof item === 'string';\n  const len = (arr || str) && item.length;\n  if (arr) return len === 33 || len === 65;\n  if (str) return len === 66 || len === 130;\n  if (item instanceof Point) return true;\n  return false;\n}\nexport function getSharedSecret(privateA, publicB) {\n  let isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (isPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');\n  if (!isPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');\n  const b = normalizePublicKey(publicB);\n  b.assertValidity();\n  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n  const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n  return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n  const z1 = bits2int(bytes);\n  const z2 = mod(z1, CURVE.n);\n  return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n  if (typeof num !== 'bigint') throw new Error('Expected bigint');\n  const hex = numTo32bStr(num);\n  return hexToBytes(hex);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n  if (msgHash == null) throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n  const h1 = ensureBytes(msgHash);\n  const d = normalizePrivateKey(privateKey);\n  const seedArgs = [int2octets(d), bits2octets(h1)];\n  if (extraEntropy != null) {\n    if (extraEntropy === true) extraEntropy = utils.randomBytes(32);\n    const e = ensureBytes(extraEntropy);\n    if (e.length !== 32) throw new Error('sign: Expected 32 bytes of extra data');\n    seedArgs.push(e);\n  }\n  const seed = concatBytes(...seedArgs);\n  const m = bits2int(h1);\n  return {\n    seed,\n    m,\n    d\n  };\n}\nfunction finalizeSig(recSig, opts) {\n  let {\n    sig,\n    recovery\n  } = recSig;\n  const {\n    canonical,\n    der,\n    recovered\n  } = Object.assign({\n    canonical: true,\n    der: true\n  }, opts);\n  if (canonical && sig.hasHighS()) {\n    sig = sig.normalizeS();\n    recovery ^= 1;\n  }\n  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n  return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    seed,\n    m,\n    d\n  } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n  let sig;\n  const drbg = new HmacDrbg();\n  await drbg.reseed(seed);\n  while (!(sig = kmdToSig(await drbg.generate(), m, d))) await drbg.reseed();\n  return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    seed,\n    m,\n    d\n  } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n  let sig;\n  const drbg = new HmacDrbg();\n  drbg.reseedSync(seed);\n  while (!(sig = kmdToSig(drbg.generateSync(), m, d))) drbg.reseedSync();\n  return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = {\n  strict: true\n};\nexport function verify(signature, msgHash, publicKey) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vopts;\n  let sig;\n  try {\n    sig = normalizeSignature(signature);\n    msgHash = ensureBytes(msgHash);\n  } catch (error) {\n    return false;\n  }\n  const {\n    r,\n    s\n  } = sig;\n  if (opts.strict && sig.hasHighS()) return false;\n  const h = truncateHash(msgHash);\n  let P;\n  try {\n    P = normalizePublicKey(publicKey);\n  } catch (error) {\n    return false;\n  }\n  const {\n    n\n  } = CURVE;\n  const sinv = invert(s, n);\n  const u1 = mod(h * sinv, n);\n  const u2 = mod(r * sinv, n);\n  const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n  if (!R) return false;\n  const v = mod(R.x, n);\n  return v === r;\n}\nfunction finalizeSchnorrChallenge(ch) {\n  return mod(bytesToNumber(ch), CURVE.n);\n}\nfunction hasEvenY(point) {\n  return (point.y & _1n) === _0n;\n}\nclass SchnorrSignature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n    if (bytes.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n    const r = bytesToNumber(bytes.subarray(0, 32));\n    const s = bytesToNumber(bytes.subarray(32, 64));\n    return new SchnorrSignature(r, s);\n  }\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');\n  }\n  toHex() {\n    return numTo32bStr(this.r) + numTo32bStr(this.s);\n  }\n  toRawBytes() {\n    return hexToBytes(this.toHex());\n  }\n}\nfunction schnorrGetPublicKey(privateKey) {\n  return Point.fromPrivateKey(privateKey).toRawX();\n}\nfunction initSchnorrSigArgs(message, privateKey, auxRand) {\n  if (message == null) throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n  const m = ensureBytes(message);\n  const d0 = normalizePrivateKey(privateKey);\n  const rand = ensureBytes(auxRand);\n  if (rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');\n  const P = Point.fromPrivateKey(d0);\n  const px = P.toRawX();\n  const d = hasEvenY(P) ? d0 : CURVE.n - d0;\n  return {\n    m,\n    P,\n    px,\n    d,\n    rand\n  };\n}\nfunction initSchnorrNonce(d, t0h) {\n  return numTo32b(d ^ bytesToNumber(t0h));\n}\nfunction finalizeSchnorrNonce(k0h) {\n  const k0 = mod(bytesToNumber(k0h), CURVE.n);\n  if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');\n  const R = Point.fromPrivateKey(k0);\n  const rx = R.toRawX();\n  const k = hasEvenY(R) ? k0 : CURVE.n - k0;\n  return {\n    R,\n    rx,\n    k\n  };\n}\nfunction finalizeSchnorrSig(R, k, e, d) {\n  return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n}\nasync function schnorrSign(message, privateKey) {\n  let auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils.randomBytes();\n  const {\n    m,\n    px,\n    d,\n    rand\n  } = initSchnorrSigArgs(message, privateKey, auxRand);\n  const t = initSchnorrNonce(d, await utils.taggedHash(TAGS.aux, rand));\n  const {\n    R,\n    rx,\n    k\n  } = finalizeSchnorrNonce(await utils.taggedHash(TAGS.nonce, t, px, m));\n  const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, rx, px, m));\n  const sig = finalizeSchnorrSig(R, k, e, d);\n  const isValid = await schnorrVerify(sig, m, px);\n  if (!isValid) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\nfunction schnorrSignSync(message, privateKey) {\n  let auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils.randomBytes();\n  const {\n    m,\n    px,\n    d,\n    rand\n  } = initSchnorrSigArgs(message, privateKey, auxRand);\n  const t = initSchnorrNonce(d, utils.taggedHashSync(TAGS.aux, rand));\n  const {\n    R,\n    rx,\n    k\n  } = finalizeSchnorrNonce(utils.taggedHashSync(TAGS.nonce, t, px, m));\n  const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, rx, px, m));\n  const sig = finalizeSchnorrSig(R, k, e, d);\n  const isValid = schnorrVerifySync(sig, m, px);\n  if (!isValid) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n  const raw = signature instanceof SchnorrSignature;\n  const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n  if (raw) sig.assertValidity();\n  return {\n    ...sig,\n    m: ensureBytes(message),\n    P: normalizePublicKey(publicKey)\n  };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n  const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n  if (!R || !hasEvenY(R) || R.x !== r) return false;\n  return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n  try {\n    const {\n      r,\n      s,\n      m,\n      P\n    } = initSchnorrVerify(signature, message, publicKey);\n    const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    return false;\n  }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n  try {\n    const {\n      r,\n      s,\n      m,\n      P\n    } = initSchnorrVerify(signature, message, publicKey);\n    const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    return false;\n  }\n}\nexport const schnorr = {\n  Signature: SchnorrSignature,\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  signSync: schnorrSignSync,\n  verifySync: schnorrVerifySync\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n  node: nodeCrypto,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nconst TAGS = {\n  challenge: 'BIP0340/challenge',\n  aux: 'BIP0340/aux',\n  nonce: 'BIP0340/nonce'\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n  isValidPrivateKey(privateKey) {\n    try {\n      normalizePrivateKey(privateKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n  privateAdd: (privateKey, tweak) => {\n    const p = normalizePrivateKey(privateKey);\n    const t = normalizePrivateKey(tweak);\n    return numTo32b(mod(p + t, CURVE.n));\n  },\n  privateNegate: privateKey => {\n    const p = normalizePrivateKey(privateKey);\n    return numTo32b(CURVE.n - p);\n  },\n  pointAddScalar: (p, tweak, isCompressed) => {\n    const P = Point.fromHex(p);\n    const t = normalizePrivateKey(tweak);\n    const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);\n    if (!Q) throw new Error('Tweaked point at infinity');\n    return Q.toRawBytes(isCompressed);\n  },\n  pointMultiply: (p, tweak, isCompressed) => {\n    const P = Point.fromHex(p);\n    const t = bytesToNumber(ensureBytes(tweak));\n    return P.multiply(t).toRawBytes(isCompressed);\n  },\n  hashToPrivateKey: hash => {\n    hash = ensureBytes(hash);\n    if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n    const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n    return numTo32b(num);\n  },\n  randomBytes: function () {\n    let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      const {\n        randomBytes\n      } = crypto.node;\n      return Uint8Array.from(randomBytes(bytesLength));\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: () => {\n    return utils.hashToPrivateKey(utils.randomBytes(40));\n  },\n  bytesToHex,\n  hexToBytes,\n  concatBytes,\n  mod,\n  invert,\n  sha256: async function () {\n    for (var _len4 = arguments.length, messages = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      messages[_key4] = arguments[_key4];\n    }\n    if (crypto.web) {\n      const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      const {\n        createHash\n      } = crypto.node;\n      const hash = createHash('sha256');\n      messages.forEach(m => hash.update(m));\n      return Uint8Array.from(hash.digest());\n    } else {\n      throw new Error(\"The environment doesn't have sha256 function\");\n    }\n  },\n  hmacSha256: async function (key) {\n    for (var _len5 = arguments.length, messages = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      messages[_key5 - 1] = arguments[_key5];\n    }\n    if (crypto.web) {\n      const ckey = await crypto.web.subtle.importKey('raw', key, {\n        name: 'HMAC',\n        hash: {\n          name: 'SHA-256'\n        }\n      }, false, ['sign']);\n      const message = concatBytes(...messages);\n      const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      const {\n        createHmac\n      } = crypto.node;\n      const hash = createHmac('sha256', key);\n      messages.forEach(m => hash.update(m));\n      return Uint8Array.from(hash.digest());\n    } else {\n      throw new Error(\"The environment doesn't have hmac-sha256 function\");\n    }\n  },\n  sha256Sync: undefined,\n  hmacSha256Sync: undefined,\n  taggedHash: async function (tag) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n      const tagH = await utils.sha256(Uint8Array.from(tag, c => c.charCodeAt(0)));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    for (var _len6 = arguments.length, messages = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      messages[_key6 - 1] = arguments[_key6];\n    }\n    return utils.sha256(tagP, ...messages);\n  },\n  taggedHashSync: function (tag) {\n    if (typeof utils.sha256Sync !== 'function') throw new Error('utils.sha256Sync is undefined, you need to set it');\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n      const tagH = utils.sha256Sync(Uint8Array.from(tag, c => c.charCodeAt(0)));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    for (var _len7 = arguments.length, messages = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      messages[_key7 - 1] = arguments[_key7];\n    }\n    return utils.sha256Sync(tagP, ...messages);\n  },\n  precompute() {\n    let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n    cached._setWindowSize(windowSize);\n    cached.multiply(_3n);\n    return cached;\n  }\n};","map":{"version":3,"names":["nodeCrypto","_0n","BigInt","_1n","_2n","_3n","_8n","POW_2_256","CURVE","a","b","P","n","h","Gx","Gy","beta","weistrass","x","x2","mod","x3","USE_ENDOMORPHISM","JacobianPoint","constructor","y","z","fromAffine","p","Point","TypeError","toAffineBatch","points","toInv","invertBatch","map","i","toAffine","normalizeZ","equals","other","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","negate","double","A","B","C","D","E","F","X3","Y3","Z3","add","H","r","ZERO","HH","HHH","V","subtract","multiplyUnsafe","scalar","P0","normalizeScalar","d","k1neg","k1","k2neg","k2","splitScalarEndo","k1p","k2p","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","Error","precomputes","pointPrecomputes","get","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","pr","cached","Math","abs","multiply","point","fake","f1p","f2p","invZ","arguments","length","undefined","invert","iz1","iz2","iz3","ax","ay","zz","WeakMap","_setWindowSize","delete","fromCompressedHex","bytes","isShort","bytesToNumber","subarray","isValidFieldElement","y2","sqrtMod","isYOdd","isFirstByteOdd","assertValidity","fromUncompressedHex","fromHex","hex","ensureBytes","len","header","fromPrivateKey","privateKey","normalizePrivateKey","fromSignature","msgHash","signature","recovery","truncateHash","s","normalizeSignature","prefix","R","numTo32bStr","rinv","u1","u2","Q","multiplyAndAddUnsafe","toRawBytes","isCompressed","hexToBytes","toHex","toHexX","slice","toRawX","msg","left","right","aP","bQ","sum","sliceDER","parseInt","parseDERInt","data","bytesToHex","res","parseDERSignature","sBytes","rBytesLeft","Signature","fromCompact","arr","isUint8a","name","str","hexToNumber","fromDER","isWithinCurveOrder","hasHighS","HALF","normalizeS","toDERRawBytes","toDERHex","sHex","numberToHexUnpadded","rHex","rLen","sLen","toCompactRawBytes","toCompactHex","concatBytes","_len","arrays","Array","_key","every","reduce","result","Uint8Array","pad","hexes","from","v","toString","padStart","uint8a","num","numTo32b","array","j","hexByte","byte","isNaN","isSafeInteger","pow2","power","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","number","modulo","u","q","m","gcd","nums","scratch","lastMultiplied","acc","inverted","reduceRight","divNearest","POW_2_128","k","a1","b1","a2","c1","c2","hash","byteLength","delta","HmacDrbg","fill","counter","hmac","_len2","values","_key2","utils","hmacSha256","hmacSync","hmacSha256Sync","_len3","_key3","Promise","incr","reseed","seed","reseedSync","generate","generateSync","kmdToSig","kBytes","sig","key","normalizePublicKey","publicKey","error","getPublicKey","recoverPublicKey","isPub","item","getSharedSecret","privateA","publicB","bits2int","bits2octets","z1","z2","int2octets","initSigArgs","extraEntropy","h1","seedArgs","randomBytes","e","finalizeSig","recSig","opts","canonical","der","recovered","Object","assign","hashed","sign","privKey","drbg","signSync","vopts","strict","verify","sinv","finalizeSchnorrChallenge","ch","hasEvenY","SchnorrSignature","schnorrGetPublicKey","initSchnorrSigArgs","message","auxRand","d0","rand","px","initSchnorrNonce","t0h","finalizeSchnorrNonce","k0h","k0","rx","finalizeSchnorrSig","schnorrSign","t","taggedHash","TAGS","aux","nonce","challenge","isValid","schnorrVerify","schnorrSignSync","taggedHashSync","schnorrVerifySync","initSchnorrVerify","raw","finalizeSchnorrVerify","schnorr","verifySync","crypto","node","web","self","TAGGED_HASH_PREFIXES","isValidPrivateKey","privateAdd","tweak","privateNegate","pointAddScalar","pointMultiply","hashToPrivateKey","bytesLength","getRandomValues","randomPrivateKey","sha256","_len4","messages","_key4","buffer","subtle","digest","createHash","forEach","update","_len5","_key5","ckey","importKey","createHmac","sha256Sync","tag","tagP","tagH","c","charCodeAt","_len6","_key6","_len7","_key7","precompute"],"sources":["/Users/oguzhansenol/Developer/Repositories/lottery-project-interface/node_modules/@noble/secp256k1/lib/esm/index.js"],"sourcesContent":["/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst POW_2_256 = _2n ** BigInt(256);\nconst CURVE = {\n    a: _0n,\n    b: BigInt(7),\n    P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),\n    n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n};\nexport { CURVE };\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 ** _2n);\n        const B = mod(Y1 ** _2n);\n        const C = mod(B ** _2n);\n        const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E ** _2n);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H ** _2n);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r ** _2n - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weistrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, 33));\n        const y = bytesToNumber(bytes.subarray(33, 65));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === 65 && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        msgHash = ensureBytes(msgHash);\n        const h = truncateHash(msgHash);\n        const { r, s } = normalizeSignature(signature);\n        if (recovery !== 0 && recovery !== 1) {\n            throw new Error('Cannot recover signature: invalid recovery bit');\n        }\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(r));\n        const { n } = CURVE;\n        const rinv = invert(r, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.y & _1n ? '03' : '02';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weistrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = isUint8a(hex);\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = isUint8a(hex);\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n    }\n    toDERRawBytes(isCompressed = false) {\n        return hexToBytes(this.toDERHex(isCompressed));\n    }\n    toDERHex(isCompressed = false) {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const rLen = numberToHexUnpadded(rHex.length / 2);\n        const sLen = numberToHexUnpadded(sHex.length / 2);\n        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every(isUint8a))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction isUint8a(bytes) {\n    return bytes instanceof Uint8Array;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction numTo32bStr(num) {\n    if (num > POW_2_256)\n        throw new Error('Expected number < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    return hexToBytes(numTo32bStr(num));\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    return pow2(t2, _2n);\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst POW_2_128 = _2n ** BigInt(128);\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n    const b2 = a1;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg)\n        k1 = n - k1;\n    if (k2neg)\n        k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction truncateHash(hash) {\n    const { n } = CURVE;\n    const byteLength = hash.length;\n    const delta = byteLength * 8 - 256;\n    let h = bytesToNumber(hash);\n    if (delta > 0)\n        h = h >> BigInt(delta);\n    if (h >= n)\n        h -= n;\n    return h;\n}\nclass HmacDrbg {\n    constructor() {\n        this.v = new Uint8Array(32).fill(1);\n        this.k = new Uint8Array(32).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        if (typeof utils.hmacSha256Sync !== 'function')\n            throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n        const res = utils.hmacSha256Sync(this.k, ...values);\n        if (res instanceof Promise)\n            throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n        return res;\n    }\n    incr() {\n        if (this.counter >= 1000) {\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        }\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        this.v = await this.hmac(this.v);\n        return this.v;\n    }\n    generateSync() {\n        this.incr();\n        this.v = this.hmacSync(this.v);\n        return this.v;\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n    const k = bytesToNumber(kBytes);\n    if (!isWithinCurveOrder(k))\n        return;\n    const { n } = CURVE;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(invert(k, n) * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    const sig = new Signature(r, s);\n    const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 64)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (isUint8a(key)) {\n        if (key.length !== 32)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isPub(item) {\n    const arr = isUint8a(item);\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    const hex = numTo32bStr(num);\n    return hexToBytes(hex);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(32);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== 32)\n            throw new Error('sign: Expected 32 bytes of extra data');\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    let { sig, recovery } = recSig;\n    const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    if (canonical && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    await drbg.reseed(seed);\n    while (!(sig = kmdToSig(await drbg.generate(), m, d)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    drbg.reseedSync(seed);\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction finalizeSchnorrChallenge(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nfunction hasEvenY(point) {\n    return (point.y & _1n) === _0n;\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nfunction initSchnorrSigArgs(message, privateKey, auxRand) {\n    if (message == null)\n        throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n    const m = ensureBytes(message);\n    const d0 = normalizePrivateKey(privateKey);\n    const rand = ensureBytes(auxRand);\n    if (rand.length !== 32)\n        throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    const P = Point.fromPrivateKey(d0);\n    const px = P.toRawX();\n    const d = hasEvenY(P) ? d0 : CURVE.n - d0;\n    return { m, P, px, d, rand };\n}\nfunction initSchnorrNonce(d, t0h) {\n    return numTo32b(d ^ bytesToNumber(t0h));\n}\nfunction finalizeSchnorrNonce(k0h) {\n    const k0 = mod(bytesToNumber(k0h), CURVE.n);\n    if (k0 === _0n)\n        throw new Error('sign: Creation of signature failed. k is zero');\n    const R = Point.fromPrivateKey(k0);\n    const rx = R.toRawX();\n    const k = hasEvenY(R) ? k0 : CURVE.n - k0;\n    return { R, rx, k };\n}\nfunction finalizeSchnorrSig(R, k, e, d) {\n    return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n}\nasync function schnorrSign(message, privateKey, auxRand = utils.randomBytes()) {\n    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);\n    const t = initSchnorrNonce(d, await utils.taggedHash(TAGS.aux, rand));\n    const { R, rx, k } = finalizeSchnorrNonce(await utils.taggedHash(TAGS.nonce, t, px, m));\n    const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, rx, px, m));\n    const sig = finalizeSchnorrSig(R, k, e, d);\n    const isValid = await schnorrVerify(sig, m, px);\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nfunction schnorrSignSync(message, privateKey, auxRand = utils.randomBytes()) {\n    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);\n    const t = initSchnorrNonce(d, utils.taggedHashSync(TAGS.aux, rand));\n    const { R, rx, k } = finalizeSchnorrNonce(utils.taggedHashSync(TAGS.nonce, t, px, m));\n    const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, rx, px, m));\n    const sig = finalizeSchnorrSig(R, k, e, d);\n    const isValid = schnorrVerifySync(sig, m, px);\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !hasEvenY(R) || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    privateAdd: (privateKey, tweak) => {\n        const p = normalizePrivateKey(privateKey);\n        const t = normalizePrivateKey(tweak);\n        return numTo32b(mod(p + t, CURVE.n));\n    },\n    privateNegate: (privateKey) => {\n        const p = normalizePrivateKey(privateKey);\n        return numTo32b(CURVE.n - p);\n    },\n    pointAddScalar: (p, tweak, isCompressed) => {\n        const P = Point.fromHex(p);\n        const t = normalizePrivateKey(tweak);\n        const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);\n        if (!Q)\n            throw new Error('Tweaked point at infinity');\n        return Q.toRawBytes(isCompressed);\n    },\n    pointMultiply: (p, tweak, isCompressed) => {\n        const P = Point.fromHex(p);\n        const t = bytesToNumber(ensureBytes(tweak));\n        return P.multiply(t).toRawBytes(isCompressed);\n    },\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.hashToPrivateKey(utils.randomBytes(40));\n    },\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof utils.sha256Sync !== 'function')\n            throw new Error('utils.sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = utils.sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256Sync(tagP, ...messages);\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}