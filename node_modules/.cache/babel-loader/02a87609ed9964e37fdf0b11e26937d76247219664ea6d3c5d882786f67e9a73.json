{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;\nconst index_js_1 = require(\"../../utils/index.js\");\n/**\n * @_ignore:\n */\nexports.WordSize = 32;\nconst Padding = new Uint8Array(exports.WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nfunction throwError(name, error) {\n  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n  wrapped.error = error;\n  throw wrapped;\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nclass Result extends Array {\n  #names;\n  /**\n   *  @private\n   */\n  constructor() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    // To properly sub-class Array so the other built-in\n    // functions work, the constructor has to behave fairly\n    // well. So, in the event we are created via fromItems()\n    // we build the read-only Result object we want, but on\n    // any other input, we use the default constructor\n    // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n    const guard = args[0];\n    let items = args[1];\n    let names = (args[2] || []).slice();\n    let wrap = true;\n    if (guard !== _guard) {\n      items = args;\n      names = [];\n      wrap = false;\n    }\n    // Can't just pass in ...items since an array of length 1\n    // is a special case in the super.\n    super(items.length);\n    items.forEach((item, index) => {\n      this[index] = item;\n    });\n    // Find all unique keys\n    const nameCounts = names.reduce((accum, name) => {\n      if (typeof name === \"string\") {\n        accum.set(name, (accum.get(name) || 0) + 1);\n      }\n      return accum;\n    }, new Map());\n    // Remove any key thats not unique\n    this.#names = Object.freeze(items.map((item, index) => {\n      const name = names[index];\n      if (name != null && nameCounts.get(name) === 1) {\n        return name;\n      }\n      return null;\n    }));\n    if (!wrap) {\n      return;\n    }\n    // A wrapped Result is immutable\n    Object.freeze(this);\n    // Proxy indices and names so we can trap deferred errors\n    return new Proxy(this, {\n      get: (target, prop, receiver) => {\n        if (typeof prop === \"string\") {\n          // Index accessor\n          if (prop.match(/^[0-9]+$/)) {\n            const index = (0, index_js_1.getNumber)(prop, \"%index\");\n            if (index < 0 || index >= this.length) {\n              throw new RangeError(\"out of result range\");\n            }\n            const item = target[index];\n            if (item instanceof Error) {\n              throwError(`index ${index}`, item);\n            }\n            return item;\n          }\n          // Pass important checks (like `then` for Promise) through\n          if (passProperties.indexOf(prop) >= 0) {\n            return Reflect.get(target, prop, receiver);\n          }\n          const value = target[prop];\n          if (value instanceof Function) {\n            // Make sure functions work with private variables\n            // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n            return function () {\n              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n              }\n              return value.apply(this === receiver ? target : this, args);\n            };\n          } else if (!(prop in target)) {\n            // Possible name accessor\n            return target.getValue.apply(this === receiver ? target : this, [prop]);\n          }\n        }\n        return Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n  /**\n   *  Returns the Result as a normal Array.\n   *\n   *  This will throw if there are any outstanding deferred\n   *  errors.\n   */\n  toArray() {\n    const result = [];\n    this.forEach((item, index) => {\n      if (item instanceof Error) {\n        throwError(`index ${index}`, item);\n      }\n      result.push(item);\n    });\n    return result;\n  }\n  /**\n   *  Returns the Result as an Object with each name-value pair.\n   *\n   *  This will throw if any value is unnamed, or if there are\n   *  any outstanding deferred errors.\n   */\n  toObject() {\n    return this.#names.reduce((accum, name, index) => {\n      (0, index_js_1.assert)(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"toObject()\"\n      });\n      // Add values for names that don't conflict\n      if (!(name in accum)) {\n        accum[name] = this.getValue(name);\n      }\n      return accum;\n    }, {});\n  }\n  /**\n   *  @_ignore\n   */\n  slice(start, end) {\n    if (start == null) {\n      start = 0;\n    }\n    if (start < 0) {\n      start += this.length;\n      if (start < 0) {\n        start = 0;\n      }\n    }\n    if (end == null) {\n      end = this.length;\n    }\n    if (end < 0) {\n      end += this.length;\n      if (end < 0) {\n        end = 0;\n      }\n    }\n    if (end > this.length) {\n      end = this.length;\n    }\n    const result = [],\n      names = [];\n    for (let i = start; i < end; i++) {\n      result.push(this[i]);\n      names.push(this.#names[i]);\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  @_ignore\n   */\n  filter(callback, thisArg) {\n    const result = [],\n      names = [];\n    for (let i = 0; i < this.length; i++) {\n      const item = this[i];\n      if (item instanceof Error) {\n        throwError(`index ${i}`, item);\n      }\n      if (callback.call(thisArg, item, i, this)) {\n        result.push(item);\n        names.push(this.#names[i]);\n      }\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  Returns the value for %%name%%.\n   *\n   *  Since it is possible to have a key whose name conflicts with\n   *  a method on a [[Result]] or its superclass Array, or any\n   *  JavaScript keyword, this ensures all named values are still\n   *  accessible by name.\n   */\n  getValue(name) {\n    const index = this.#names.indexOf(name);\n    if (index === -1) {\n      return undefined;\n    }\n    const value = this[index];\n    if (value instanceof Error) {\n      throwError(`property ${JSON.stringify(name)}`, value.error);\n    }\n    return value;\n  }\n  /**\n   *  Creates a new [[Result]] for %%items%% with each entry\n   *  also accessible by its corresponding name in %%keys%%.\n   */\n  static fromItems(items, keys) {\n    return new Result(_guard, items, keys);\n  }\n}\nexports.Result = Result;\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nfunction checkResultErrors(result) {\n  // Find the first error (if any)\n  const errors = [];\n  const checkErrors = function (path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (let key in object) {\n      const childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nexports.checkResultErrors = checkResultErrors;\nfunction getValue(value) {\n  let bytes = (0, index_js_1.toBeArray)(value);\n  (0, index_js_1.assert)(bytes.length <= exports.WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n    buffer: bytes,\n    length: exports.WordSize,\n    offset: bytes.length\n  });\n  if (bytes.length !== exports.WordSize) {\n    bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([Padding.slice(bytes.length % exports.WordSize), bytes]));\n  }\n  return bytes;\n}\n/**\n *  @_ignore\n */\nclass Coder {\n  // The coder name:\n  //   - address, uint256, tuple, array, etc.\n  name;\n  // The fully expanded type, including composite types:\n  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n  type;\n  // The localName bound in the signature, in this example it is \"baz\":\n  //   - tuple(address foo, uint bar) baz\n  localName;\n  // Whether this type is dynamic:\n  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n  dynamic;\n  constructor(name, type, localName, dynamic) {\n    (0, index_js_1.defineProperties)(this, {\n      name,\n      type,\n      localName,\n      dynamic\n    }, {\n      name: \"string\",\n      type: \"string\",\n      localName: \"string\",\n      dynamic: \"boolean\"\n    });\n  }\n  _throwError(message, value) {\n    (0, index_js_1.assertArgument)(false, message, this.localName, value);\n  }\n}\nexports.Coder = Coder;\n/**\n *  @_ignore\n */\nclass Writer {\n  // An array of WordSize lengthed objects to concatenation\n  #data;\n  #dataLength;\n  constructor() {\n    this.#data = [];\n    this.#dataLength = 0;\n  }\n  get data() {\n    return (0, index_js_1.concat)(this.#data);\n  }\n  get length() {\n    return this.#dataLength;\n  }\n  #writeData(data) {\n    this.#data.push(data);\n    this.#dataLength += data.length;\n    return data.length;\n  }\n  appendWriter(writer) {\n    return this.#writeData((0, index_js_1.getBytesCopy)(writer.data));\n  }\n  // Arrayish item; pad on the right to *nearest* WordSize\n  writeBytes(value) {\n    let bytes = (0, index_js_1.getBytesCopy)(value);\n    const paddingOffset = bytes.length % exports.WordSize;\n    if (paddingOffset) {\n      bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([bytes, Padding.slice(paddingOffset)]));\n    }\n    return this.#writeData(bytes);\n  }\n  // Numeric item; pad on the left *to* WordSize\n  writeValue(value) {\n    return this.#writeData(getValue(value));\n  }\n  // Inserts a numeric place-holder, returning a callback that can\n  // be used to asjust the value later\n  writeUpdatableValue() {\n    const offset = this.#data.length;\n    this.#data.push(Padding);\n    this.#dataLength += exports.WordSize;\n    return value => {\n      this.#data[offset] = getValue(value);\n    };\n  }\n}\nexports.Writer = Writer;\n/**\n *  @_ignore\n */\nclass Reader {\n  // Allows incomplete unpadded data to be read; otherwise an error\n  // is raised if attempting to overrun the buffer. This is required\n  // to deal with an old Solidity bug, in which event data for\n  // external (not public thoguh) was tightly packed.\n  allowLoose;\n  #data;\n  #offset;\n  constructor(data, allowLoose) {\n    (0, index_js_1.defineProperties)(this, {\n      allowLoose: !!allowLoose\n    });\n    this.#data = (0, index_js_1.getBytesCopy)(data);\n    this.#offset = 0;\n  }\n  get data() {\n    return (0, index_js_1.hexlify)(this.#data);\n  }\n  get dataLength() {\n    return this.#data.length;\n  }\n  get consumed() {\n    return this.#offset;\n  }\n  get bytes() {\n    return new Uint8Array(this.#data);\n  }\n  #peekBytes(offset, length, loose) {\n    let alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;\n    if (this.#offset + alignedLength > this.#data.length) {\n      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n        alignedLength = length;\n      } else {\n        (0, index_js_1.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n          buffer: (0, index_js_1.getBytesCopy)(this.#data),\n          length: this.#data.length,\n          offset: this.#offset + alignedLength\n        });\n      }\n    }\n    return this.#data.slice(this.#offset, this.#offset + alignedLength);\n  }\n  // Create a sub-reader with the same underlying data, but offset\n  subReader(offset) {\n    return new Reader(this.#data.slice(this.#offset + offset), this.allowLoose);\n  }\n  // Read bytes\n  readBytes(length, loose) {\n    let bytes = this.#peekBytes(0, length, !!loose);\n    this.#offset += bytes.length;\n    // @TODO: Make sure the length..end bytes are all 0?\n    return bytes.slice(0, length);\n  }\n  // Read a numeric values\n  readValue() {\n    return (0, index_js_1.toBigInt)(this.readBytes(exports.WordSize));\n  }\n  readIndex() {\n    return (0, index_js_1.toNumber)(this.readBytes(exports.WordSize));\n  }\n}\nexports.Reader = Reader;","map":{"version":3,"names":["index_js_1","require","exports","WordSize","Padding","Uint8Array","passProperties","_guard","throwError","name","error","wrapped","Error","Result","Array","names","constructor","_len","arguments","length","args","_key","guard","items","slice","wrap","forEach","item","index","nameCounts","reduce","accum","set","get","Map","Object","freeze","map","Proxy","target","prop","receiver","match","getNumber","RangeError","indexOf","Reflect","value","Function","_len2","_key2","apply","getValue","toArray","result","push","toObject","assert","operation","start","end","i","filter","callback","thisArg","call","undefined","JSON","stringify","fromItems","keys","checkResultErrors","errors","checkErrors","path","object","isArray","key","childPath","bytes","toBeArray","buffer","offset","getBytesCopy","concat","Coder","type","localName","dynamic","defineProperties","_throwError","message","assertArgument","Writer","data","dataLength","writeData","#writeData","appendWriter","writer","writeBytes","paddingOffset","writeValue","writeUpdatableValue","Reader","allowLoose","hexlify","consumed","peekBytes","#peekBytes","loose","alignedLength","Math","ceil","subReader","readBytes","readValue","toBigInt","readIndex","toNumber"],"sources":["/Users/oguzhansenol/Developer/Repositories/lottery-project-interface/node_modules/ethers/src.ts/abi/coders/abstract-coder.ts"],"sourcesContent":["\nimport {\n    defineProperties, concat, getBytesCopy, getNumber, hexlify,\n    toBeArray, toBigInt, toNumber,\n    assert, assertArgument\n} from \"../../utils/index.js\";\n\nimport type { BigNumberish, BytesLike } from \"../../utils/index.js\";\n\n/**\n * @_ignore:\n */\nexport const WordSize: number = 32;\nconst Padding = new Uint8Array(WordSize);\n\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [ \"then\" ];\n\nconst _guard = { };\n\nfunction throwError(name: string, error: Error): never {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${ name }`);\n    (<any>wrapped).error = error;\n    throw wrapped;\n}\n\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nexport class Result extends Array<any> {\n    readonly #names: ReadonlyArray<null | string>;\n\n    [ K: string | number ]: any\n\n    /**\n     *  @private\n     */\n    constructor(...args: Array<any>) {\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items: Array<any> = args[1];\n        let names: Array<null | string> = (args[2] || [ ]).slice();\n\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [ ];\n            wrap = false;\n        }\n\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index) => { this[index] = item; });\n\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name) => {\n            if (typeof(name) === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, <Map<string, number>>(new Map()));\n\n        // Remove any key thats not unique\n        this.#names = Object.freeze(items.map((item, index) => {\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        }));\n\n        if (!wrap) { return; }\n\n        // A wrapped Result is immutable\n        Object.freeze(this);\n\n        // Proxy indices and names so we can trap deferred errors\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof(prop) === \"string\") {\n\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = getNumber(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${ index }`, item);\n                        }\n                        return item;\n                    }\n\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function(this: any, ...args: Array<any>) {\n                            return value.apply((this === receiver) ? target: this, args);\n                        };\n\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply((this === receiver) ? target: this, [ prop ]);\n                    }\n                }\n\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n\n    /**\n     *  Returns the Result as a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */\n    toArray(): Array<any> {\n        const result: Array<any> = [ ];\n        this.forEach((item, index) => {\n            if (item instanceof Error) { throwError(`index ${ index }`, item); }\n            result.push(item);\n        });\n        return result;\n    }\n\n    /**\n     *  Returns the Result as an Object with each name-value pair.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n    toObject(): Record<string, any> {\n        return this.#names.reduce((accum, name, index) => {\n            assert(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n\n            // Add values for names that don't conflict\n            if (!(name in accum)) {\n                accum[name] = this.getValue(name);\n            }\n\n            return accum;\n        }, <Record<string, any>>{});\n    }\n\n    /**\n     *  @_ignore\n     */\n    slice(start?: number | undefined, end?: number | undefined): Result {\n        if (start == null) { start = 0; }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) { start = 0; }\n        }\n\n        if (end == null) { end = this.length; }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) { end = 0; }\n        }\n        if (end > this.length) { end = this.length; }\n\n        const result = [ ], names = [ ];\n        for (let i = start; i < end; i++) {\n            result.push(this[i]);\n            names.push(this.#names[i]);\n        }\n\n        return new Result(_guard, result, names);\n    }\n\n    /**\n     *  @_ignore\n     */\n    filter(callback: (el: any, index: number, array: Result) => boolean, thisArg?: any): Result {\n        const result = [ ], names = [ ];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${ i }`, item);\n            }\n\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(this.#names[i]);\n            }\n        }\n\n        return new Result(_guard, result, names);\n    }\n\n\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n    getValue(name: string): any {\n        const index = this.#names.indexOf(name);\n        if (index === -1) { return undefined; }\n\n        const value = this[index];\n\n        if (value instanceof Error) {\n            throwError(`property ${ JSON.stringify(name) }`, (<any>value).error);\n        }\n\n        return value;\n    }\n\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n    static fromItems(items: Array<any>, keys?: Array<null | string>): Result {\n        return new Result(_guard, items, keys);\n    }\n}\n\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error: any) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nfunction getValue(value: BigNumberish): Uint8Array {\n    let bytes = toBeArray(value);\n\n    assert (bytes.length <= WordSize, \"value out-of-bounds\",\n        \"BUFFER_OVERRUN\", { buffer: bytes, length: WordSize, offset: bytes.length });\n\n    if (bytes.length !== WordSize) {\n        bytes = getBytesCopy(concat([ Padding.slice(bytes.length % WordSize), bytes ]));\n    }\n\n    return bytes;\n}\n\n/**\n *  @_ignore\n */\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name!: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type!: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName!: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic!: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        defineProperties<Coder>(this, { name, type, localName, dynamic }, {\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\n        });\n    }\n\n    _throwError(message: string, value: any): never {\n        assertArgument(false, message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\n/**\n *  @_ignore\n */\nexport class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data: Array<Uint8Array>;\n    #dataLength: number;\n\n    constructor() {\n        this.#data = [ ];\n        this.#dataLength = 0;\n    }\n\n    get data(): string {\n        return concat(this.#data);\n    }\n    get length(): number { return this.#dataLength; }\n\n    #writeData(data: Uint8Array): number {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this.#writeData(getBytesCopy(writer.data));\n    }\n\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = getBytesCopy(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = getBytesCopy(concat([ bytes, Padding.slice(paddingOffset) ]))\n        }\n        return this.#writeData(bytes);\n    }\n\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value: BigNumberish): number {\n        return this.#writeData(getValue(value));\n    }\n\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value: BigNumberish) => {\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n\n/**\n *  @_ignore\n */\nexport class Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    readonly allowLoose!: boolean;\n\n    readonly #data: Uint8Array;\n    #offset: number;\n\n    constructor(data: BytesLike, allowLoose?: boolean) {\n        defineProperties<Reader>(this, { allowLoose: !!allowLoose });\n\n        this.#data = getBytesCopy(data);\n\n        this.#offset = 0;\n    }\n\n    get data(): string { return hexlify(this.#data); }\n    get dataLength(): number { return this.#data.length; }\n    get consumed(): number { return this.#offset; }\n    get bytes(): Uint8Array { return new Uint8Array(this.#data); }\n\n    #peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            } else {\n                assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: getBytesCopy(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength)\n    }\n\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset: number): Reader {\n        return new Reader(this.#data.slice(this.#offset + offset), this.allowLoose);\n    }\n\n    // Read bytes\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    // Read a numeric values\n    readValue(): bigint {\n        return toBigInt(this.readBytes(WordSize));\n    }\n\n    readIndex(): number {\n        return toNumber(this.readBytes(WordSize));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}