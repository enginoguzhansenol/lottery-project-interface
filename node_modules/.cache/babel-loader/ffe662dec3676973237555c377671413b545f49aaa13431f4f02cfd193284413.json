{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Contract = exports.BaseContract = exports.resolveArgs = exports.copyOverrides = void 0;\nconst index_js_1 = require(\"../abi/index.js\");\nconst index_js_2 = require(\"../address/index.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nconst provider_js_1 = require(\"../providers/provider.js\");\nconst index_js_3 = require(\"../utils/index.js\");\nconst wrappers_js_1 = require(\"./wrappers.js\");\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n  return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n  return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n  return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n  return value && typeof value.sendTransaction === \"function\";\n}\nclass PreparedTopicFilter {\n  #filter;\n  fragment;\n  constructor(contract, fragment, args) {\n    (0, index_js_3.defineProperties)(this, {\n      fragment\n    });\n    if (fragment.inputs.length < args.length) {\n      throw new Error(\"too many arguments\");\n    }\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(contract.runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    this.#filter = async function () {\n      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n        const arg = args[index];\n        if (arg == null) {\n          return null;\n        }\n        return param.walkAsync(args[index], (type, value) => {\n          if (type === \"address\") {\n            return (0, index_js_2.resolveAddress)(value, resolver);\n          }\n          return value;\n        });\n      }));\n      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n    }();\n  }\n  getTopicFilter() {\n    return this.#filter;\n  }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n  if (value == null) {\n    return null;\n  }\n  if (typeof value[feature] === \"function\") {\n    return value;\n  }\n  if (value.provider && typeof value.provider[feature] === \"function\") {\n    return value.provider;\n  }\n  return null;\n}\nfunction getProvider(value) {\n  if (value == null) {\n    return null;\n  }\n  return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nasync function copyOverrides(arg, allowed) {\n  // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n  const overrides = (0, provider_js_1.copyRequest)(index_js_1.Typed.dereference(arg, \"overrides\"));\n  (0, index_js_3.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n  (0, index_js_3.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n  // Resolve any from\n  if (overrides.from) {\n    overrides.from = await (0, index_js_2.resolveAddress)(overrides.from);\n  }\n  return overrides;\n}\nexports.copyOverrides = copyOverrides;\n/**\n *  @_ignore:\n */\nasync function resolveArgs(_runner, inputs, args) {\n  // Recursively descend into args and resolve any addresses\n  const runner = getRunner(_runner, \"resolveName\");\n  const resolver = canResolve(runner) ? runner : null;\n  return await Promise.all(inputs.map((param, index) => {\n    return param.walkAsync(args[index], (type, value) => {\n      value = index_js_1.Typed.dereference(value, type);\n      if (type === \"address\") {\n        return (0, index_js_2.resolveAddress)(value, resolver);\n      }\n      return value;\n    });\n  }));\n}\nexports.resolveArgs = resolveArgs;\nfunction buildWrappedFallback(contract) {\n  const populateTransaction = async function (overrides) {\n    // If an overrides was passed in, copy it and normalize the values\n    const tx = await copyOverrides(overrides, [\"data\"]);\n    tx.to = await contract.getAddress();\n    const iface = contract.interface;\n    // Only allow payable contracts to set non-zero value\n    const payable = iface.receive || iface.fallback && iface.fallback.payable;\n    (0, index_js_3.assertArgument)(payable || (tx.value || BN_0) === BN_0, \"cannot send value to non-payable contract\", \"overrides.value\", tx.value);\n    // Only allow fallback contracts to set non-empty data\n    (0, index_js_3.assertArgument)(iface.fallback || (tx.data || \"0x\") === \"0x\", \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n    return tx;\n  };\n  const staticCall = async function (overrides) {\n    const runner = getRunner(contract.runner, \"call\");\n    (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"call\"\n    });\n    const tx = await populateTransaction(overrides);\n    try {\n      return await runner.call(tx);\n    } catch (error) {\n      if ((0, index_js_3.isCallException)(error) && error.data) {\n        throw contract.interface.makeError(error.data, tx);\n      }\n      throw error;\n    }\n  };\n  const send = async function (overrides) {\n    const runner = contract.runner;\n    (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"sendTransaction\"\n    });\n    const tx = await runner.sendTransaction(await populateTransaction(overrides));\n    const provider = getProvider(contract.runner);\n    // @TODO: the provider can be null; make a custom dummy provider that will throw a\n    // meaningful error\n    return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);\n  };\n  const estimateGas = async function (overrides) {\n    const runner = getRunner(contract.runner, \"estimateGas\");\n    (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"estimateGas\"\n    });\n    return await runner.estimateGas(await populateTransaction(overrides));\n  };\n  const method = async overrides => {\n    return await send(overrides);\n  };\n  (0, index_js_3.defineProperties)(method, {\n    _contract: contract,\n    estimateGas,\n    populateTransaction,\n    send,\n    staticCall\n  });\n  return method;\n}\nfunction buildWrappedMethod(contract, key) {\n  const getFragment = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const fragment = contract.interface.getFunction(key, args);\n    (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\"\n    });\n    return fragment;\n  };\n  const populateTransaction = async function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const fragment = getFragment(...args);\n    // If an overrides was passed in, copy it and normalize the values\n    let overrides = {};\n    if (fragment.inputs.length + 1 === args.length) {\n      overrides = await copyOverrides(args.pop());\n    }\n    if (fragment.inputs.length !== args.length) {\n      throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n    }\n    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n    return Object.assign({}, overrides, await (0, index_js_3.resolveProperties)({\n      to: contract.getAddress(),\n      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n    }));\n  };\n  const staticCall = async function () {\n    const result = await staticCallResult(...arguments);\n    if (result.length === 1) {\n      return result[0];\n    }\n    return result;\n  };\n  const send = async function () {\n    const runner = contract.runner;\n    (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"sendTransaction\"\n    });\n    const tx = await runner.sendTransaction(await populateTransaction(...arguments));\n    const provider = getProvider(contract.runner);\n    // @TODO: the provider can be null; make a custom dummy provider that will throw a\n    // meaningful error\n    return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);\n  };\n  const estimateGas = async function () {\n    const runner = getRunner(contract.runner, \"estimateGas\");\n    (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"estimateGas\"\n    });\n    return await runner.estimateGas(await populateTransaction(...arguments));\n  };\n  const staticCallResult = async function () {\n    const runner = getRunner(contract.runner, \"call\");\n    (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"call\"\n    });\n    const tx = await populateTransaction(...arguments);\n    let result = \"0x\";\n    try {\n      result = await runner.call(tx);\n    } catch (error) {\n      if ((0, index_js_3.isCallException)(error) && error.data) {\n        throw contract.interface.makeError(error.data, tx);\n      }\n      throw error;\n    }\n    const fragment = getFragment(...arguments);\n    return contract.interface.decodeFunctionResult(fragment, result);\n  };\n  const method = async function () {\n    const fragment = getFragment(...arguments);\n    if (fragment.constant) {\n      return await staticCall(...arguments);\n    }\n    return await send(...arguments);\n  };\n  (0, index_js_3.defineProperties)(method, {\n    name: contract.interface.getFunctionName(key),\n    _contract: contract,\n    _key: key,\n    getFragment,\n    estimateGas,\n    populateTransaction,\n    send,\n    staticCall,\n    staticCallResult\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: () => {\n      const fragment = contract.interface.getFunction(key);\n      (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\"\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\nfunction buildWrappedEvent(contract, key) {\n  const getFragment = function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    const fragment = contract.interface.getEvent(key, args);\n    (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\"\n    });\n    return fragment;\n  };\n  const method = function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return new PreparedTopicFilter(contract, getFragment(...args), args);\n  };\n  (0, index_js_3.defineProperties)(method, {\n    name: contract.interface.getEventName(key),\n    _contract: contract,\n    _key: key,\n    getFragment\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: () => {\n      const fragment = contract.interface.getEvent(key);\n      (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\"\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n  internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n  return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n  return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nasync function getSubInfo(contract, event) {\n  let topics;\n  let fragment = null;\n  // Convert named events to topicHash and get the fragment for\n  // events which need deconstructing.\n  if (Array.isArray(event)) {\n    const topicHashify = function (name) {\n      if ((0, index_js_3.isHexString)(name, 32)) {\n        return name;\n      }\n      const fragment = contract.interface.getEvent(name);\n      (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n      return fragment.topicHash;\n    };\n    // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n    topics = event.map(e => {\n      if (e == null) {\n        return null;\n      }\n      if (Array.isArray(e)) {\n        return e.map(topicHashify);\n      }\n      return topicHashify(e);\n    });\n  } else if (event === \"*\") {\n    topics = [null];\n  } else if (typeof event === \"string\") {\n    if ((0, index_js_3.isHexString)(event, 32)) {\n      // Topic Hash\n      topics = [event];\n    } else {\n      // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n      fragment = contract.interface.getEvent(event);\n      (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n      topics = [fragment.topicHash];\n    }\n  } else if (isDeferred(event)) {\n    // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n    topics = await event.getTopicFilter();\n  } else if (\"fragment\" in event) {\n    // ContractEvent; e.g. `contract.filter.Transfer`\n    fragment = event.fragment;\n    topics = [fragment.topicHash];\n  } else {\n    (0, index_js_3.assertArgument)(false, \"unknown event name\", \"event\", event);\n  }\n  // Normalize topics and sort TopicSets\n  topics = topics.map(t => {\n    if (t == null) {\n      return null;\n    }\n    if (Array.isArray(t)) {\n      const items = Array.from(new Set(t.map(t => t.toLowerCase())).values());\n      if (items.length === 1) {\n        return items[0];\n      }\n      items.sort();\n      return items;\n    }\n    return t.toLowerCase();\n  });\n  const tag = topics.map(t => {\n    if (t == null) {\n      return \"null\";\n    }\n    if (Array.isArray(t)) {\n      return t.join(\"|\");\n    }\n    return t;\n  }).join(\"&\");\n  return {\n    fragment,\n    tag,\n    topics\n  };\n}\nasync function hasSub(contract, event) {\n  const {\n    subs\n  } = getInternal(contract);\n  return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n  // Make sure our runner can actually subscribe to events\n  const provider = getProvider(contract.runner);\n  (0, index_js_3.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n    operation\n  });\n  const {\n    fragment,\n    tag,\n    topics\n  } = await getSubInfo(contract, event);\n  const {\n    addr,\n    subs\n  } = getInternal(contract);\n  let sub = subs.get(tag);\n  if (!sub) {\n    const address = addr ? addr : contract;\n    const filter = {\n      address,\n      topics\n    };\n    const listener = log => {\n      let foundFragment = fragment;\n      if (foundFragment == null) {\n        try {\n          foundFragment = contract.interface.getEvent(log.topics[0]);\n        } catch (error) {}\n      }\n      // If fragment is null, we do not deconstruct the args to emit\n      if (foundFragment) {\n        const _foundFragment = foundFragment;\n        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n        emit(contract, event, args, listener => {\n          return new wrappers_js_1.ContractEventPayload(contract, listener, event, _foundFragment, log);\n        });\n      } else {\n        emit(contract, event, [], listener => {\n          return new wrappers_js_1.ContractUnknownEventPayload(contract, listener, event, log);\n        });\n      }\n    };\n    let starting = [];\n    const start = () => {\n      if (starting.length) {\n        return;\n      }\n      starting.push(provider.on(filter, listener));\n    };\n    const stop = async () => {\n      if (starting.length == 0) {\n        return;\n      }\n      let started = starting;\n      starting = [];\n      await Promise.all(started);\n      provider.off(filter, listener);\n    };\n    sub = {\n      tag,\n      listeners: [],\n      start,\n      stop\n    };\n    subs.set(tag, sub);\n  }\n  return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n  await lastEmit;\n  const sub = await hasSub(contract, event);\n  if (!sub) {\n    return false;\n  }\n  const count = sub.listeners.length;\n  sub.listeners = sub.listeners.filter(_ref => {\n    let {\n      listener,\n      once\n    } = _ref;\n    const passArgs = Array.from(args);\n    if (payloadFunc) {\n      passArgs.push(payloadFunc(once ? null : listener));\n    }\n    try {\n      listener.call(contract, ...passArgs);\n    } catch (error) {}\n    return !once;\n  });\n  return count > 0;\n}\nasync function emit(contract, event, args, payloadFunc) {\n  try {\n    await lastEmit;\n  } catch (error) {}\n  const resultPromise = _emit(contract, event, args, payloadFunc);\n  lastEmit = resultPromise;\n  return await resultPromise;\n}\nconst passProperties = [\"then\"];\nclass BaseContract {\n  target;\n  interface;\n  runner;\n  filters;\n  [internal];\n  fallback;\n  constructor(target, abi, runner, _deployTx) {\n    if (runner == null) {\n      runner = null;\n    }\n    const iface = index_js_1.Interface.from(abi);\n    (0, index_js_3.defineProperties)(this, {\n      target,\n      runner,\n      interface: iface\n    });\n    Object.defineProperty(this, internal, {\n      value: {}\n    });\n    let addrPromise;\n    let addr = null;\n    let deployTx = null;\n    if (_deployTx) {\n      const provider = getProvider(runner);\n      // @TODO: the provider can be null; make a custom dummy provider that will throw a\n      // meaningful error\n      deployTx = new wrappers_js_1.ContractTransactionResponse(this.interface, provider, _deployTx);\n    }\n    let subs = new Map();\n    // Resolve the target as the address\n    if (typeof target === \"string\") {\n      if ((0, index_js_3.isHexString)(target)) {\n        addr = target;\n        addrPromise = Promise.resolve(target);\n      } else {\n        const resolver = getRunner(runner, \"resolveName\");\n        if (!canResolve(resolver)) {\n          throw (0, index_js_3.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n          });\n        }\n        addrPromise = resolver.resolveName(target).then(addr => {\n          if (addr == null) {\n            throw new Error(\"TODO\");\n          }\n          getInternal(this).addr = addr;\n          return addr;\n        });\n      }\n    } else {\n      addrPromise = target.getAddress().then(addr => {\n        if (addr == null) {\n          throw new Error(\"TODO\");\n        }\n        getInternal(this).addr = addr;\n        return addr;\n      });\n    }\n    // Set our private values\n    setInternal(this, {\n      addrPromise,\n      addr,\n      deployTx,\n      subs\n    });\n    // Add the event filters\n    const filters = new Proxy({}, {\n      get: (target, _prop, receiver) => {\n        // Pass important checks (like `then` for Promise) through\n        if (passProperties.indexOf(_prop) >= 0) {\n          return Reflect.get(target, _prop, receiver);\n        }\n        const prop = String(_prop);\n        const result = this.getEvent(prop);\n        if (result) {\n          return result;\n        }\n        throw new Error(`unknown contract event: ${prop}`);\n      },\n      has: (target, prop) => {\n        // Pass important checks (like `then` for Promise) through\n        if (passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n      }\n    });\n    (0, index_js_3.defineProperties)(this, {\n      filters\n    });\n    (0, index_js_3.defineProperties)(this, {\n      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n    });\n    // Return a Proxy that will respond to functions\n    return new Proxy(this, {\n      get: (target, _prop, receiver) => {\n        if (_prop in target || passProperties.indexOf(_prop) >= 0) {\n          return Reflect.get(target, _prop, receiver);\n        }\n        const prop = String(_prop);\n        const result = target.getFunction(prop);\n        if (result) {\n          return result;\n        }\n        throw new Error(`unknown contract method: ${prop}`);\n      },\n      has: (target, prop) => {\n        if (prop in target || passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return target.interface.hasFunction(String(prop));\n      }\n    });\n  }\n  connect(runner) {\n    return new BaseContract(this.target, this.interface, runner);\n  }\n  async getAddress() {\n    return await getInternal(this).addrPromise;\n  }\n  async getDeployedCode() {\n    const provider = getProvider(this.runner);\n    (0, index_js_3.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"getDeployedCode\"\n    });\n    const code = await provider.getCode(await this.getAddress());\n    if (code === \"0x\") {\n      return null;\n    }\n    return code;\n  }\n  async waitForDeployment() {\n    // We have the deployement transaction; just use that (throws if deployement fails)\n    const deployTx = this.deploymentTransaction();\n    if (deployTx) {\n      await deployTx.wait();\n      return this;\n    }\n    // Check for code\n    const code = await this.getDeployedCode();\n    if (code != null) {\n      return this;\n    }\n    // Make sure we can subscribe to a provider event\n    const provider = getProvider(this.runner);\n    (0, index_js_3.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"waitForDeployment\"\n    });\n    return new Promise((resolve, reject) => {\n      const checkCode = async () => {\n        try {\n          const code = await this.getDeployedCode();\n          if (code != null) {\n            return resolve(this);\n          }\n          provider.once(\"block\", checkCode);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      checkCode();\n    });\n  }\n  deploymentTransaction() {\n    return getInternal(this).deployTx;\n  }\n  getFunction(key) {\n    if (typeof key !== \"string\") {\n      key = key.format();\n    }\n    const func = buildWrappedMethod(this, key);\n    return func;\n  }\n  getEvent(key) {\n    if (typeof key !== \"string\") {\n      key = key.format();\n    }\n    return buildWrappedEvent(this, key);\n  }\n  async queryTransaction(hash) {\n    // Is this useful?\n    throw new Error(\"@TODO\");\n  }\n  async queryFilter(event, fromBlock, toBlock) {\n    if (fromBlock == null) {\n      fromBlock = 0;\n    }\n    if (toBlock == null) {\n      toBlock = \"latest\";\n    }\n    const {\n      addr,\n      addrPromise\n    } = getInternal(this);\n    const address = addr ? addr : await addrPromise;\n    const {\n      fragment,\n      topics\n    } = await getSubInfo(this, event);\n    const filter = {\n      address,\n      topics,\n      fromBlock,\n      toBlock\n    };\n    const provider = getProvider(this.runner);\n    (0, index_js_3.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"queryFilter\"\n    });\n    return (await provider.getLogs(filter)).map(log => {\n      let foundFragment = fragment;\n      if (foundFragment == null) {\n        try {\n          foundFragment = this.interface.getEvent(log.topics[0]);\n        } catch (error) {}\n      }\n      if (foundFragment) {\n        return new wrappers_js_1.EventLog(log, this.interface, foundFragment);\n      } else {\n        return new provider_js_1.Log(log, provider);\n      }\n    });\n  }\n  async on(event, listener) {\n    const sub = await getSub(this, \"on\", event);\n    sub.listeners.push({\n      listener,\n      once: false\n    });\n    sub.start();\n    return this;\n  }\n  async once(event, listener) {\n    const sub = await getSub(this, \"once\", event);\n    sub.listeners.push({\n      listener,\n      once: true\n    });\n    sub.start();\n    return this;\n  }\n  async emit(event) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n    return await emit(this, event, args, null);\n  }\n  async listenerCount(event) {\n    if (event) {\n      const sub = await hasSub(this, event);\n      if (!sub) {\n        return 0;\n      }\n      return sub.listeners.length;\n    }\n    const {\n      subs\n    } = getInternal(this);\n    let total = 0;\n    for (const {\n      listeners\n    } of subs.values()) {\n      total += listeners.length;\n    }\n    return total;\n  }\n  async listeners(event) {\n    if (event) {\n      const sub = await hasSub(this, event);\n      if (!sub) {\n        return [];\n      }\n      return sub.listeners.map(_ref2 => {\n        let {\n          listener\n        } = _ref2;\n        return listener;\n      });\n    }\n    const {\n      subs\n    } = getInternal(this);\n    let result = [];\n    for (const {\n      listeners\n    } of subs.values()) {\n      result = result.concat(listeners.map(_ref3 => {\n        let {\n          listener\n        } = _ref3;\n        return listener;\n      }));\n    }\n    return result;\n  }\n  async off(event, listener) {\n    const sub = await hasSub(this, event);\n    if (!sub) {\n      return this;\n    }\n    if (listener) {\n      const index = sub.listeners.map(_ref4 => {\n        let {\n          listener\n        } = _ref4;\n        return listener;\n      }).indexOf(listener);\n      if (index >= 0) {\n        sub.listeners.splice(index, 1);\n      }\n    }\n    if (listener == null || sub.listeners.length === 0) {\n      sub.stop();\n      getInternal(this).subs.delete(sub.tag);\n    }\n    return this;\n  }\n  async removeAllListeners(event) {\n    if (event) {\n      const sub = await hasSub(this, event);\n      if (!sub) {\n        return this;\n      }\n      sub.stop();\n      getInternal(this).subs.delete(sub.tag);\n    } else {\n      const {\n        subs\n      } = getInternal(this);\n      for (const {\n        tag,\n        stop\n      } of subs.values()) {\n        stop();\n        subs.delete(tag);\n      }\n    }\n    return this;\n  }\n  // Alias for \"on\"\n  async addListener(event, listener) {\n    return await this.on(event, listener);\n  }\n  // Alias for \"off\"\n  async removeListener(event, listener) {\n    return await this.off(event, listener);\n  }\n  static buildClass(abi) {\n    class CustomContract extends BaseContract {\n      constructor(address) {\n        let runner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        super(address, abi, runner);\n      }\n    }\n    return CustomContract;\n  }\n  static from(target, abi, runner) {\n    if (runner == null) {\n      runner = null;\n    }\n    const contract = new this(target, abi, runner);\n    return contract;\n  }\n}\nexports.BaseContract = BaseContract;\nfunction _ContractBase() {\n  return BaseContract;\n}\nclass Contract extends _ContractBase() {}\nexports.Contract = Contract;","map":{"version":3,"names":["index_js_1","require","index_js_2","provider_js_1","index_js_3","wrappers_js_1","BN_0","BigInt","canCall","value","call","canEstimate","estimateGas","canResolve","resolveName","canSend","sendTransaction","PreparedTopicFilter","filter","fragment","constructor","contract","args","defineProperties","inputs","length","Error","runner","getRunner","resolver","resolvedArgs","Promise","all","map","param","index","arg","walkAsync","type","resolveAddress","interface","encodeFilterTopics","getTopicFilter","feature","provider","getProvider","copyOverrides","allowed","overrides","copyRequest","Typed","dereference","assertArgument","to","indexOf","data","from","exports","resolveArgs","_runner","buildWrappedFallback","populateTransaction","tx","getAddress","iface","payable","receive","fallback","staticCall","assert","operation","error","isCallException","makeError","send","ContractTransactionResponse","method","_contract","buildWrappedMethod","key","getFragment","_len","arguments","Array","_key","getFunction","_len2","_key2","pop","Object","assign","resolveProperties","encodeFunctionData","result","staticCallResult","decodeFunctionResult","constant","name","getFunctionName","defineProperty","configurable","enumerable","get","buildWrappedEvent","_len3","_key3","getEvent","_len4","_key4","getEventName","internal","Symbol","for","internalValues","WeakMap","setInternal","values","set","getInternal","isDeferred","getSubInfo","event","topics","isArray","topicHashify","isHexString","topicHash","e","t","items","Set","toLowerCase","sort","tag","join","hasSub","subs","getSub","addr","sub","address","listener","log","foundFragment","_foundFragment","decodeEventLog","emit","ContractEventPayload","ContractUnknownEventPayload","starting","start","push","on","stop","started","off","listeners","lastEmit","resolve","_emit","payloadFunc","count","_ref","once","passArgs","resultPromise","passProperties","BaseContract","target","filters","abi","_deployTx","Interface","addrPromise","deployTx","Map","then","Proxy","_prop","receiver","Reflect","prop","String","has","hasEvent","hasFunction","connect","getDeployedCode","code","getCode","waitForDeployment","deploymentTransaction","wait","reject","checkCode","format","func","queryTransaction","hash","queryFilter","fromBlock","toBlock","getLogs","EventLog","Log","_len5","_key5","listenerCount","total","_ref2","concat","_ref3","_ref4","splice","delete","removeAllListeners","addListener","removeListener","buildClass","CustomContract","undefined","_ContractBase","Contract"],"sources":["/Users/oguzhansenol/Developer/Repositories/lottery-project-interface/node_modules/ethers/src.ts/contract/contract.ts"],"sourcesContent":["import { Interface, Typed } from \"../abi/index.js\";\nimport { resolveAddress } from \"../address/index.js\";\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { copyRequest, Log, TransactionResponse } from \"../providers/provider.js\";\nimport {\n    defineProperties, isCallException, isHexString, resolveProperties,\n    makeError, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport {\n    ContractEventPayload, ContractUnknownEventPayload,\n    ContractTransactionResponse,\n    EventLog\n} from \"./wrappers.js\";\n\nimport type { EventFragment, FunctionFragment, InterfaceAbi, ParamType, Result } from \"../abi/index.js\";\nimport type { Addressable } from \"../address/index.js\";\nimport type { EventEmitterable, Listener } from \"../utils/index.js\";\nimport type {\n    BlockTag, ContractRunner, Provider, TransactionRequest, TopicFilter\n} from \"../providers/index.js\";\n\nimport type {\n    BaseContractMethod,\n    ContractEventName,\n    ContractInterface,\n    ContractMethodArgs,\n    ContractMethod,\n    ContractEventArgs,\n    ContractEvent,\n    ContractTransaction,\n    DeferredTopicFilter,\n    WrappedFallback\n} from \"./types.js\";\n\nconst BN_0 = BigInt(0);\n\ninterface ContractRunnerCaller extends ContractRunner {\n    call: (tx: TransactionRequest) => Promise<string>;\n}\n\ninterface ContractRunnerEstimater extends ContractRunner {\n    estimateGas: (tx: TransactionRequest) => Promise<bigint>;\n}\n\ninterface ContractRunnerSender extends ContractRunner {\n    sendTransaction: (tx: TransactionRequest) => Promise<TransactionResponse>;\n}\n\ninterface ContractRunnerResolver extends ContractRunner {\n    resolveName: (name: string | Addressable) => Promise<null | string>;\n}\n\nfunction canCall(value: any): value is ContractRunnerCaller {\n    return (value && typeof(value.call) === \"function\");\n}\n\nfunction canEstimate(value: any): value is ContractRunnerEstimater {\n    return (value && typeof(value.estimateGas) === \"function\");\n}\n\nfunction canResolve(value: any): value is ContractRunnerResolver {\n    return (value && typeof(value.resolveName) === \"function\");\n}\n\nfunction canSend(value: any): value is ContractRunnerSender {\n    return (value && typeof(value.sendTransaction) === \"function\");\n}\n\nclass PreparedTopicFilter implements DeferredTopicFilter {\n    #filter: Promise<TopicFilter>;\n    readonly fragment!: EventFragment;\n\n    constructor(contract: BaseContract, fragment: EventFragment, args: Array<any>) {\n        defineProperties<PreparedTopicFilter>(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner: null;\n        this.#filter = (async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) { return null; }\n\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        return resolveAddress(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n\n    getTopicFilter(): Promise<TopicFilter> {\n        return this.#filter;\n    }\n}\n\n\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\n\nfunction getRunner<T extends ContractRunner>(value: any, feature: keyof ContractRunner): null | T {\n    if (value == null) { return null; }\n    if (typeof(value[feature]) === \"function\") { return value; }\n    if (value.provider && typeof(value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\n\nfunction getProvider(value: null | ContractRunner): null | Provider {\n    if (value == null) { return null; }\n    return value.provider || null;\n}\n\n/**\n *  @_ignore:\n */\nexport async function copyOverrides<O extends string = \"data\" | \"to\">(arg: any, allowed?: Array<string>): Promise<Omit<ContractTransaction, O>> {\n\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = copyRequest(Typed.dereference(arg, \"overrides\"));\n\n    assertArgument(overrides.to == null || (allowed || [ ]).indexOf(\"to\") >= 0,\n      \"cannot override to\", \"overrides.to\", overrides.to);\n    assertArgument(overrides.data == null || (allowed || [ ]).indexOf(\"data\") >= 0,\n      \"cannot override data\", \"overrides.data\", overrides.data);\n\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = await resolveAddress(overrides.from);\n    }\n\n    return <Omit<ContractTransaction, O>>overrides;\n}\n\n/**\n *  @_ignore:\n */\nexport async function resolveArgs(_runner: null | ContractRunner, inputs: ReadonlyArray<ParamType>, args: Array<any>): Promise<Array<any>> {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner: null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = Typed.dereference(value, type);\n            if (type === \"address\") { return resolveAddress(value, resolver); }\n            return value;\n        });\n    }));\n}\n\nfunction buildWrappedFallback(contract: BaseContract): WrappedFallback {\n\n    const populateTransaction = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransaction> {\n        // If an overrides was passed in, copy it and normalize the values\n\n        const tx: ContractTransaction = <any>(await copyOverrides<\"data\">(overrides, [ \"data\" ]));\n        tx.to = await contract.getAddress();\n\n        const iface = contract.interface;\n\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        assertArgument(payable || (tx.value || BN_0) === BN_0,\n          \"cannot send value to non-payable contract\", \"overrides.value\", tx.value);\n\n        // Only allow fallback contracts to set non-empty data\n        assertArgument(iface.fallback || (tx.data || \"0x\") === \"0x\",\n          \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n\n        return tx;\n    }\n\n    const staticCall = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<string> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(overrides);\n\n        try {\n            return await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    }\n\n    const send = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(overrides));\n    }\n\n    const method = async (overrides?: Omit<TransactionRequest, \"to\">) => {\n        return await send(overrides);\n    };\n\n    defineProperties<any>(method, {\n        _contract: contract,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n\n    return <WrappedFallback>method;\n}\n\nfunction buildWrappedMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse>(contract: BaseContract, key: string): BaseContractMethod<A, R, D> {\n\n    const getFragment = function(...args: ContractMethodArgs<A>): FunctionFragment {\n        const fragment = contract.interface.getFunction(key, args);\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\"\n        });\n        return fragment;\n    }\n\n    const populateTransaction = async function(...args: ContractMethodArgs<A>): Promise<ContractTransaction> {\n        const fragment = getFragment(...args);\n\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides: Omit<ContractTransaction, \"data\" | \"to\"> = { };\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n        }\n\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n\n        return Object.assign({ }, overrides, await resolveProperties({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    }\n\n    const staticCall = async function(...args: ContractMethodArgs<A>): Promise<R> {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) { return result[0]; }\n        return <R><unknown>result;\n    }\n\n    const send = async function(...args: ContractMethodArgs<A>): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(...args: ContractMethodArgs<A>): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(...args));\n    }\n\n    const staticCallResult = async function(...args: ContractMethodArgs<A>): Promise<Result> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(...args);\n\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n\n    const method = async (...args: ContractMethodArgs<A>) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) { return await staticCall(...args); }\n        return await send(...args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n\n        getFragment,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\"\n            });\n            return fragment;\n        }\n    });\n\n    return <BaseContractMethod<A, R, D>>method;\n}\n\nfunction buildWrappedEvent<A extends Array<any> = Array<any>>(contract: BaseContract, key: string): ContractEvent<A> {\n\n    const getFragment = function(...args: ContractEventArgs<A>): EventFragment {\n        const fragment = contract.interface.getEvent(key, args);\n\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\"\n        });\n\n        return fragment;\n    }\n\n    const method = function(...args: ContractMethodArgs<A>): PreparedTopicFilter {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n\n        getFragment\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\"\n            });\n\n            return fragment;\n        }\n    });\n\n    return <ContractEvent<A>><unknown>method;\n}\n\ntype Sub = {\n    tag: string;\n    listeners: Array<{ listener: Listener, once: boolean }>,\n    start: () => void;\n    stop: () => void;\n};\n\n\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\n\nconst internal = Symbol.for(\"_ethersInternal_contract\");\ntype Internal = {\n    addrPromise: Promise<string>;\n    addr: null | string;\n\n    deployTx: null | ContractTransactionResponse;\n\n    subs: Map<string, Sub>;\n};\n\nconst internalValues: WeakMap<BaseContract, Internal> = new WeakMap();\n\nfunction setInternal(contract: BaseContract, values: Internal): void {\n    internalValues.set(contract[internal], values);\n}\n\nfunction getInternal(contract: BaseContract): Internal {\n    return internalValues.get(contract[internal]) as Internal;\n}\n\nfunction isDeferred(value: any): value is DeferredTopicFilter {\n    return (value && typeof(value) === \"object\" && (\"getTopicFilter\" in value) &&\n      (typeof(value.getTopicFilter) === \"function\") && value.fragment);\n}\n\nasync function getSubInfo(contract: BaseContract, event: ContractEventName): Promise<{ fragment: null | EventFragment, tag: string, topics: TopicFilter }> {\n    let topics: Array<null | string | Array<string>>;\n    let fragment: null | EventFragment = null;\n\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n\n    if (Array.isArray(event)) {\n        const topicHashify = function(name: string): string {\n            if (isHexString(name, 32)) { return name; }\n            const fragment = contract.interface.getEvent(name);\n            assertArgument(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        }\n\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) { return null; }\n            if (Array.isArray(e)) { return e.map(topicHashify); }\n            return topicHashify(e);\n        });\n\n    } else if (event === \"*\") {\n        topics = [ null ];\n\n    } else if (typeof(event) === \"string\") {\n        if (isHexString(event, 32)) {\n            // Topic Hash\n            topics = [ event ];\n        } else {\n           // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            assertArgument(fragment, \"unknown fragment\", \"event\", event);\n            topics = [ fragment.topicHash ];\n        }\n\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [ fragment.topicHash ];\n\n    } else {\n        assertArgument(false, \"unknown event name\", \"event\", event);\n    }\n\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) { return null; }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) { return items[0]; }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n\n    const tag = topics.map((t) => {\n        if (t == null) { return \"null\"; }\n        if (Array.isArray(t)) { return t.join(\"|\"); }\n        return t;\n    }).join(\"&\");\n\n    return { fragment, tag, topics }\n}\n\nasync function hasSub(contract: BaseContract, event: ContractEventName): Promise<null | Sub> {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\n\nasync function getSub(contract: BaseContract, operation: string, event: ContractEventName): Promise<Sub> {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    assert(provider, \"contract runner does not support subscribing\",\n        \"UNSUPPORTED_OPERATION\", { operation });\n\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n\n    const { addr, subs } = getInternal(contract);\n\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address: string | Addressable = (addr ? addr: contract);\n        const filter = { address, topics };\n        const listener = (log: Log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            // If fragment is null, we do not deconstruct the args to emit\n\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics): [ ];\n                emit(contract, event, args, (listener: null | Listener) => {\n                    return new ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [ ], (listener: null | Listener) => {\n                    return new ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n\n        let starting: Array<Promise<any>> = [ ];\n        const start = () => {\n            if (starting.length) { return; }\n            starting.push(provider.on(filter, listener));\n        };\n\n        const stop = async () => {\n            if (starting.length == 0) { return; }\n\n            let started = starting;\n            starting = [ ];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n\n        sub = { tag, listeners: [ ], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit: Promise<any> = Promise.resolve();\n\ntype PayloadFunc = (listener: null | Listener) => ContractUnknownEventPayload;\n\nasync function _emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    await lastEmit;\n\n    const sub = await hasSub(contract, event);\n    if (!sub) { return false; }\n\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null: listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) { }\n        return !once;\n    });\n    return (count > 0);\n}\n\nasync function emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    try {\n        await lastEmit;\n    } catch (error) { }\n\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\n\nconst passProperties = [ \"then\" ];\nexport class BaseContract implements Addressable, EventEmitterable<ContractEventName> {\n    readonly target!: string | Addressable;\n    readonly interface!: Interface;\n    readonly runner!: null | ContractRunner;\n\n    readonly filters!: Record<string, ContractEvent>;\n\n    readonly [internal]: any;\n\n    readonly fallback!: null | WrappedFallback;\n\n    constructor(target: string | Addressable, abi: Interface | InterfaceAbi, runner?: null | ContractRunner, _deployTx?: null | TransactionResponse) {\n        if (runner == null) { runner = null; }\n        const iface = Interface.from(abi);\n        defineProperties<BaseContract>(this, { target, runner, interface: iface });\n\n        Object.defineProperty(this, internal, { value: { } });\n\n        let addrPromise;\n        let addr = null;\n\n        let deployTx: null | ContractTransactionResponse = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new ContractTransactionResponse(this.interface, <Provider>provider, _deployTx);\n        }\n\n        let subs = new Map();\n\n        // Resolve the target as the address\n        if (typeof(target) === \"string\") {\n            if (isHexString(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw makeError(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) { throw new Error(\"TODO\"); }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) { throw new Error(\"TODO\"); }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n\n        // Add the event filters\n        const filters = new Proxy({ }, {\n            get: (target, _prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(<string>_prop) >= 0) {\n                    return Reflect.get(target, _prop, receiver);\n                }\n\n                const prop = String(_prop);\n\n                const result = this.getEvent(prop);\n                if (result) { return result; }\n\n                throw new Error(`unknown contract event: ${ prop }`);\n            },\n            has: (target, prop) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(<string>prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        defineProperties<BaseContract>(this, { filters });\n\n        defineProperties<BaseContract>(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)): null)\n        });\n\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, _prop, receiver) => {\n                if (_prop in target || passProperties.indexOf(<string>_prop) >= 0) {\n                    return Reflect.get(target, _prop, receiver);\n                }\n\n                const prop = String(_prop);\n\n                const result = target.getFunction(prop);\n                if (result) { return result; }\n\n                throw new Error(`unknown contract method: ${ prop }`);\n            },\n            has: (target, prop) => {\n                if (prop in target || passProperties.indexOf(<string>prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n\n                return target.interface.hasFunction(String(prop));\n            }\n        });\n\n    }\n\n    connect(runner: null | ContractRunner): BaseContract {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n\n    async getAddress(): Promise<string> { return await getInternal(this).addrPromise; }\n\n    async getDeployedCode(): Promise<null | string> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") { return null; }\n        return code;\n    }\n\n    async waitForDeployment(): Promise<this> {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) { return this; }\n\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        assert(provider != null, \"contract runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) { return resolve(this); }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n\n    deploymentTransaction(): null | ContractTransactionResponse {\n        return getInternal(this).deployTx;\n    }\n\n    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        const func = buildWrappedMethod(this, key);\n        return <T>func;\n    }\n\n    getEvent(key: string | EventFragment): ContractEvent {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        return buildWrappedEvent(this, key);\n    }\n\n    async queryTransaction(hash: string): Promise<Array<EventLog>> {\n        // Is this useful?\n        throw new Error(\"@TODO\");\n    }\n\n    async queryFilter(event: ContractEventName, fromBlock?: BlockTag, toBlock?: BlockTag): Promise<Array<EventLog | Log>> {\n        if (fromBlock == null) { fromBlock = 0; }\n        if (toBlock == null) { toBlock = \"latest\"; }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr: (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            if (foundFragment) {\n                return new EventLog(log, this.interface, foundFragment);\n            } else {\n                return new Log(log, provider);\n            }\n        });\n    }\n\n    async on(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n\n    async once(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n\n    async emit(event: ContractEventName, ...args: Array<any>): Promise<boolean> {\n        return await emit(this, event, args, null);\n    }\n\n    async listenerCount(event?: ContractEventName): Promise<number> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        const { subs } = getInternal(this);\n\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n\n    async listeners(event?: ContractEventName): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n\n        const { subs } = getInternal(this);\n\n        let result: Array<Listener> = [ ];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n\n    async off(event: ContractEventName, listener?: Listener): Promise<this> {\n        const sub = await hasSub(this, event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { sub.listeners.splice(index, 1); }\n        }\n\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n\n        return this;\n    }\n\n    async removeAllListeners(event?: ContractEventName): Promise<this> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return this; }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n\n        return this;\n    }\n\n    // Alias for \"on\"\n    async addListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.on(event, listener);\n    }\n\n    // Alias for \"off\"\n    async removeListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.off(event, listener);\n    }\n\n    static buildClass<T = ContractInterface>(abi: InterfaceAbi): new (target: string, runner?: null | ContractRunner) => BaseContract & Omit<T, keyof BaseContract> {\n        class CustomContract extends BaseContract {\n            constructor(address: string, runner: null | ContractRunner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract as any;\n    };\n\n    static from<T = ContractInterface>(target: string, abi: InterfaceAbi, runner?: null | ContractRunner): BaseContract & Omit<T, keyof BaseContract> {\n        if (runner == null) { runner = null; }\n        const contract = new this(target, abi, runner );\n        return contract as any;\n    }\n}\n\nfunction _ContractBase(): new (target: string, abi: InterfaceAbi, runner?: null | ContractRunner) => BaseContract & Omit<ContractInterface, keyof BaseContract> {\n    return BaseContract as any;\n}\n\nexport class Contract extends _ContractBase() { }\n"],"mappings":";;;;;;AAAA,MAAAA,UAAA,GAAAC,OAAA;AACA,MAAAC,UAAA,GAAAD,OAAA;AACA;AACA;AACA,MAAAE,aAAA,GAAAF,OAAA;AACA,MAAAG,UAAA,GAAAH,OAAA;AAKA,MAAAI,aAAA,GAAAJ,OAAA;AA0BA,MAAMK,IAAI,GAAGC,MAAM,CAAC,CAAC,CAAC;AAkBtB,SAASC,OAAOA,CAACC,KAAU;EACvB,OAAQA,KAAK,IAAI,OAAOA,KAAK,CAACC,IAAK,KAAK,UAAU;AACtD;AAEA,SAASC,WAAWA,CAACF,KAAU;EAC3B,OAAQA,KAAK,IAAI,OAAOA,KAAK,CAACG,WAAY,KAAK,UAAU;AAC7D;AAEA,SAASC,UAAUA,CAACJ,KAAU;EAC1B,OAAQA,KAAK,IAAI,OAAOA,KAAK,CAACK,WAAY,KAAK,UAAU;AAC7D;AAEA,SAASC,OAAOA,CAACN,KAAU;EACvB,OAAQA,KAAK,IAAI,OAAOA,KAAK,CAACO,eAAgB,KAAK,UAAU;AACjE;AAEA,MAAMC,mBAAmB;EACrB,CAAAC,MAAO;EACEC,QAAQ;EAEjBC,YAAYC,QAAsB,EAAEF,QAAuB,EAAEG,IAAgB;IACzE,IAAAlB,UAAA,CAAAmB,gBAAgB,EAAsB,IAAI,EAAE;MAAEJ;IAAQ,CAAE,CAAC;IACzD,IAAIA,QAAQ,CAACK,MAAM,CAACC,MAAM,GAAGH,IAAI,CAACG,MAAM,EAAE;MACtC,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;;IAGzC;IACA,MAAMC,MAAM,GAAGC,SAAS,CAACP,QAAQ,CAACM,MAAM,EAAE,aAAa,CAAC;IACxD,MAAME,QAAQ,GAAGhB,UAAU,CAACc,MAAM,CAAC,GAAGA,MAAM,GAAE,IAAI;IAClD,IAAI,CAAC,CAAAT,MAAO,GAAI,kBAAK;MACjB,MAAMY,YAAY,GAAG,MAAMC,OAAO,CAACC,GAAG,CAACb,QAAQ,CAACK,MAAM,CAACS,GAAG,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAI;QACxE,MAAMC,GAAG,GAAGd,IAAI,CAACa,KAAK,CAAC;QACvB,IAAIC,GAAG,IAAI,IAAI,EAAE;UAAE,OAAO,IAAI;;QAE9B,OAAOF,KAAK,CAACG,SAAS,CAACf,IAAI,CAACa,KAAK,CAAC,EAAE,CAACG,IAAI,EAAE7B,KAAK,KAAI;UAChD,IAAI6B,IAAI,KAAK,SAAS,EAAE;YACpB,OAAO,IAAApC,UAAA,CAAAqC,cAAc,EAAC9B,KAAK,EAAEoB,QAAQ,CAAC;;UAE1C,OAAOpB,KAAK;QAChB,CAAC,CAAC;MACN,CAAC,CAAC,CAAC;MAEH,OAAOY,QAAQ,CAACmB,SAAS,CAACC,kBAAkB,CAACtB,QAAQ,EAAEW,YAAY,CAAC;IACxE,CAAC,CAAC,CAAE;EACR;EAEAY,cAAcA,CAAA;IACV,OAAO,IAAI,CAAC,CAAAxB,MAAO;EACvB;;AAIJ;AACA;AACA;AACA;AACA;AACA;AAEA,SAASU,SAASA,CAA2BnB,KAAU,EAAEkC,OAA6B;EAClF,IAAIlC,KAAK,IAAI,IAAI,EAAE;IAAE,OAAO,IAAI;;EAChC,IAAI,OAAOA,KAAK,CAACkC,OAAO,CAAE,KAAK,UAAU,EAAE;IAAE,OAAOlC,KAAK;;EACzD,IAAIA,KAAK,CAACmC,QAAQ,IAAI,OAAOnC,KAAK,CAACmC,QAAQ,CAACD,OAAO,CAAE,KAAK,UAAU,EAAE;IAClE,OAAOlC,KAAK,CAACmC,QAAQ;;EAEzB,OAAO,IAAI;AACf;AAEA,SAASC,WAAWA,CAACpC,KAA4B;EAC7C,IAAIA,KAAK,IAAI,IAAI,EAAE;IAAE,OAAO,IAAI;;EAChC,OAAOA,KAAK,CAACmC,QAAQ,IAAI,IAAI;AACjC;AAEA;;;AAGO,eAAeE,aAAaA,CAAmCV,GAAQ,EAAEW,OAAuB;EAEnG;EACA,MAAMC,SAAS,GAAG,IAAA7C,aAAA,CAAA8C,WAAW,EAACjD,UAAA,CAAAkD,KAAK,CAACC,WAAW,CAACf,GAAG,EAAE,WAAW,CAAC,CAAC;EAElE,IAAAhC,UAAA,CAAAgD,cAAc,EAACJ,SAAS,CAACK,EAAE,IAAI,IAAI,IAAI,CAACN,OAAO,IAAI,EAAG,EAAEO,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EACxE,oBAAoB,EAAE,cAAc,EAAEN,SAAS,CAACK,EAAE,CAAC;EACrD,IAAAjD,UAAA,CAAAgD,cAAc,EAACJ,SAAS,CAACO,IAAI,IAAI,IAAI,IAAI,CAACR,OAAO,IAAI,EAAG,EAAEO,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,EAC5E,sBAAsB,EAAE,gBAAgB,EAAEN,SAAS,CAACO,IAAI,CAAC;EAE3D;EACA,IAAIP,SAAS,CAACQ,IAAI,EAAE;IAChBR,SAAS,CAACQ,IAAI,GAAG,MAAM,IAAAtD,UAAA,CAAAqC,cAAc,EAACS,SAAS,CAACQ,IAAI,CAAC;;EAGzD,OAAqCR,SAAS;AAClD;AAhBAS,OAAA,CAAAX,aAAA,GAAAA,aAAA;AAkBA;;;AAGO,eAAeY,WAAWA,CAACC,OAA8B,EAAEnC,MAAgC,EAAEF,IAAgB;EAChH;EACA,MAAMK,MAAM,GAAGC,SAAS,CAAC+B,OAAO,EAAE,aAAa,CAAC;EAChD,MAAM9B,QAAQ,GAAGhB,UAAU,CAACc,MAAM,CAAC,GAAGA,MAAM,GAAE,IAAI;EAClD,OAAO,MAAMI,OAAO,CAACC,GAAG,CAACR,MAAM,CAACS,GAAG,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAI;IACjD,OAAOD,KAAK,CAACG,SAAS,CAACf,IAAI,CAACa,KAAK,CAAC,EAAE,CAACG,IAAI,EAAE7B,KAAK,KAAI;MAChDA,KAAK,GAAGT,UAAA,CAAAkD,KAAK,CAACC,WAAW,CAAC1C,KAAK,EAAE6B,IAAI,CAAC;MACtC,IAAIA,IAAI,KAAK,SAAS,EAAE;QAAE,OAAO,IAAApC,UAAA,CAAAqC,cAAc,EAAC9B,KAAK,EAAEoB,QAAQ,CAAC;;MAChE,OAAOpB,KAAK;IAChB,CAAC,CAAC;EACN,CAAC,CAAC,CAAC;AACP;AAXAgD,OAAA,CAAAC,WAAA,GAAAA,WAAA;AAaA,SAASE,oBAAoBA,CAACvC,QAAsB;EAEhD,MAAMwC,mBAAmB,GAAG,eAAAA,CAAeb,SAA0C;IACjF;IAEA,MAAMc,EAAE,GAA8B,MAAMhB,aAAa,CAASE,SAAS,EAAE,CAAE,MAAM,CAAE,CAAE;IACzFc,EAAE,CAACT,EAAE,GAAG,MAAMhC,QAAQ,CAAC0C,UAAU,EAAE;IAEnC,MAAMC,KAAK,GAAG3C,QAAQ,CAACmB,SAAS;IAEhC;IACA,MAAMyB,OAAO,GAAGD,KAAK,CAACE,OAAO,IAAKF,KAAK,CAACG,QAAQ,IAAIH,KAAK,CAACG,QAAQ,CAACF,OAAQ;IAC3E,IAAA7D,UAAA,CAAAgD,cAAc,EAACa,OAAO,IAAI,CAACH,EAAE,CAACrD,KAAK,IAAIH,IAAI,MAAMA,IAAI,EACnD,2CAA2C,EAAE,iBAAiB,EAAEwD,EAAE,CAACrD,KAAK,CAAC;IAE3E;IACA,IAAAL,UAAA,CAAAgD,cAAc,EAACY,KAAK,CAACG,QAAQ,IAAI,CAACL,EAAE,CAACP,IAAI,IAAI,IAAI,MAAM,IAAI,EACzD,2CAA2C,EAAE,gBAAgB,EAAEO,EAAE,CAACP,IAAI,CAAC;IAEzE,OAAOO,EAAE;EACb,CAAC;EAED,MAAMM,UAAU,GAAG,eAAAA,CAAepB,SAA0C;IACxE,MAAMrB,MAAM,GAAGC,SAAS,CAACP,QAAQ,CAACM,MAAM,EAAE,MAAM,CAAC;IACjD,IAAAvB,UAAA,CAAAiE,MAAM,EAAC7D,OAAO,CAACmB,MAAM,CAAC,EAAE,0CAA0C,EAC9D,uBAAuB,EAAE;MAAE2C,SAAS,EAAE;IAAM,CAAE,CAAC;IAEnD,MAAMR,EAAE,GAAG,MAAMD,mBAAmB,CAACb,SAAS,CAAC;IAE/C,IAAI;MACA,OAAO,MAAMrB,MAAM,CAACjB,IAAI,CAACoD,EAAE,CAAC;KAC/B,CAAC,OAAOS,KAAU,EAAE;MACjB,IAAI,IAAAnE,UAAA,CAAAoE,eAAe,EAACD,KAAK,CAAC,IAAIA,KAAK,CAAChB,IAAI,EAAE;QACtC,MAAMlC,QAAQ,CAACmB,SAAS,CAACiC,SAAS,CAACF,KAAK,CAAChB,IAAI,EAAEO,EAAE,CAAC;;MAEtD,MAAMS,KAAK;;EAEnB,CAAC;EAED,MAAMG,IAAI,GAAG,eAAAA,CAAe1B,SAA0C;IAClE,MAAMrB,MAAM,GAAGN,QAAQ,CAACM,MAAM;IAC9B,IAAAvB,UAAA,CAAAiE,MAAM,EAACtD,OAAO,CAACY,MAAM,CAAC,EAAE,uDAAuD,EAC3E,uBAAuB,EAAE;MAAE2C,SAAS,EAAE;IAAiB,CAAE,CAAC;IAE9D,MAAMR,EAAE,GAAG,MAAMnC,MAAM,CAACX,eAAe,CAAC,MAAM6C,mBAAmB,CAACb,SAAS,CAAC,CAAC;IAC7E,MAAMJ,QAAQ,GAAGC,WAAW,CAACxB,QAAQ,CAACM,MAAM,CAAC;IAC7C;IACA;IACA,OAAO,IAAItB,aAAA,CAAAsE,2BAA2B,CAACtD,QAAQ,CAACmB,SAAS,EAAYI,QAAQ,EAAEkB,EAAE,CAAC;EACtF,CAAC;EAED,MAAMlD,WAAW,GAAG,eAAAA,CAAeoC,SAA0C;IACzE,MAAMrB,MAAM,GAAGC,SAAS,CAACP,QAAQ,CAACM,MAAM,EAAE,aAAa,CAAC;IACxD,IAAAvB,UAAA,CAAAiE,MAAM,EAAC1D,WAAW,CAACgB,MAAM,CAAC,EAAE,iDAAiD,EACzE,uBAAuB,EAAE;MAAE2C,SAAS,EAAE;IAAa,CAAE,CAAC;IAE1D,OAAO,MAAM3C,MAAM,CAACf,WAAW,CAAC,MAAMiD,mBAAmB,CAACb,SAAS,CAAC,CAAC;EACzE,CAAC;EAED,MAAM4B,MAAM,GAAG,MAAO5B,SAA0C,IAAI;IAChE,OAAO,MAAM0B,IAAI,CAAC1B,SAAS,CAAC;EAChC,CAAC;EAED,IAAA5C,UAAA,CAAAmB,gBAAgB,EAAMqD,MAAM,EAAE;IAC1BC,SAAS,EAAExD,QAAQ;IAEnBT,WAAW;IACXiD,mBAAmB;IACnBa,IAAI;IAAEN;GACT,CAAC;EAEF,OAAwBQ,MAAM;AAClC;AAEA,SAASE,kBAAkBA,CAAsHzD,QAAsB,EAAE0D,GAAW;EAEhL,MAAMC,WAAW,GAAG,SAAAA,CAAA,EAAuC;IAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAzD,MAAA,EAA3BH,IAA2B,OAAA6D,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;MAA3B9D,IAA2B,CAAA8D,IAAA,IAAAF,SAAA,CAAAE,IAAA;IAAA;IACvD,MAAMjE,QAAQ,GAAGE,QAAQ,CAACmB,SAAS,CAAC6C,WAAW,CAACN,GAAG,EAAEzD,IAAI,CAAC;IAC1D,IAAAlB,UAAA,CAAAiE,MAAM,EAAClD,QAAQ,EAAE,sBAAsB,EAAE,uBAAuB,EAAE;MAC9DmD,SAAS,EAAE;KACd,CAAC;IACF,OAAOnD,QAAQ;EACnB,CAAC;EAED,MAAM0C,mBAAmB,GAAG,eAAAA,CAAA,EAA6C;IAAA,SAAAyB,KAAA,GAAAJ,SAAA,CAAAzD,MAAA,EAA3BH,IAA2B,OAAA6D,KAAA,CAAAG,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAA3BjE,IAA2B,CAAAiE,KAAA,IAAAL,SAAA,CAAAK,KAAA;IAAA;IACrE,MAAMpE,QAAQ,GAAG6D,WAAW,CAAC,GAAG1D,IAAI,CAAC;IAErC;IACA,IAAI0B,SAAS,GAA6C,EAAG;IAC7D,IAAI7B,QAAQ,CAACK,MAAM,CAACC,MAAM,GAAG,CAAC,KAAKH,IAAI,CAACG,MAAM,EAAE;MAC5CuB,SAAS,GAAG,MAAMF,aAAa,CAACxB,IAAI,CAACkE,GAAG,EAAE,CAAC;;IAG/C,IAAIrE,QAAQ,CAACK,MAAM,CAACC,MAAM,KAAKH,IAAI,CAACG,MAAM,EAAE;MACxC,MAAM,IAAIC,KAAK,CAAC,4EAA4E,CAAC;;IAGjG,MAAMI,YAAY,GAAG,MAAM4B,WAAW,CAACrC,QAAQ,CAACM,MAAM,EAAER,QAAQ,CAACK,MAAM,EAAEF,IAAI,CAAC;IAE9E,OAAOmE,MAAM,CAACC,MAAM,CAAC,EAAG,EAAE1C,SAAS,EAAE,MAAM,IAAA5C,UAAA,CAAAuF,iBAAiB,EAAC;MACzDtC,EAAE,EAAEhC,QAAQ,CAAC0C,UAAU,EAAE;MACzBR,IAAI,EAAElC,QAAQ,CAACmB,SAAS,CAACoD,kBAAkB,CAACzE,QAAQ,EAAEW,YAAY;KACrE,CAAC,CAAC;EACP,CAAC;EAED,MAAMsC,UAAU,GAAG,eAAAA,CAAA,EAA6C;IAC5D,MAAMyB,MAAM,GAAG,MAAMC,gBAAgB,CAAC,GAAAZ,SAAO,CAAC;IAC9C,IAAIW,MAAM,CAACpE,MAAM,KAAK,CAAC,EAAE;MAAE,OAAOoE,MAAM,CAAC,CAAC,CAAC;;IAC3C,OAAmBA,MAAM;EAC7B,CAAC;EAED,MAAMnB,IAAI,GAAG,eAAAA,CAAA,EAA6C;IACtD,MAAM/C,MAAM,GAAGN,QAAQ,CAACM,MAAM;IAC9B,IAAAvB,UAAA,CAAAiE,MAAM,EAACtD,OAAO,CAACY,MAAM,CAAC,EAAE,uDAAuD,EAC3E,uBAAuB,EAAE;MAAE2C,SAAS,EAAE;IAAiB,CAAE,CAAC;IAE9D,MAAMR,EAAE,GAAG,MAAMnC,MAAM,CAACX,eAAe,CAAC,MAAM6C,mBAAmB,CAAC,GAAAqB,SAAO,CAAC,CAAC;IAC3E,MAAMtC,QAAQ,GAAGC,WAAW,CAACxB,QAAQ,CAACM,MAAM,CAAC;IAC7C;IACA;IACA,OAAO,IAAItB,aAAA,CAAAsE,2BAA2B,CAACtD,QAAQ,CAACmB,SAAS,EAAYI,QAAQ,EAAEkB,EAAE,CAAC;EACtF,CAAC;EAED,MAAMlD,WAAW,GAAG,eAAAA,CAAA,EAA6C;IAC7D,MAAMe,MAAM,GAAGC,SAAS,CAACP,QAAQ,CAACM,MAAM,EAAE,aAAa,CAAC;IACxD,IAAAvB,UAAA,CAAAiE,MAAM,EAAC1D,WAAW,CAACgB,MAAM,CAAC,EAAE,iDAAiD,EACzE,uBAAuB,EAAE;MAAE2C,SAAS,EAAE;IAAa,CAAE,CAAC;IAE1D,OAAO,MAAM3C,MAAM,CAACf,WAAW,CAAC,MAAMiD,mBAAmB,CAAC,GAAAqB,SAAO,CAAC,CAAC;EACvE,CAAC;EAED,MAAMY,gBAAgB,GAAG,eAAAA,CAAA,EAA6C;IAClE,MAAMnE,MAAM,GAAGC,SAAS,CAACP,QAAQ,CAACM,MAAM,EAAE,MAAM,CAAC;IACjD,IAAAvB,UAAA,CAAAiE,MAAM,EAAC7D,OAAO,CAACmB,MAAM,CAAC,EAAE,0CAA0C,EAC9D,uBAAuB,EAAE;MAAE2C,SAAS,EAAE;IAAM,CAAE,CAAC;IAEnD,MAAMR,EAAE,GAAG,MAAMD,mBAAmB,CAAC,GAAAqB,SAAO,CAAC;IAE7C,IAAIW,MAAM,GAAG,IAAI;IACjB,IAAI;MACAA,MAAM,GAAG,MAAMlE,MAAM,CAACjB,IAAI,CAACoD,EAAE,CAAC;KACjC,CAAC,OAAOS,KAAU,EAAE;MACjB,IAAI,IAAAnE,UAAA,CAAAoE,eAAe,EAACD,KAAK,CAAC,IAAIA,KAAK,CAAChB,IAAI,EAAE;QACtC,MAAMlC,QAAQ,CAACmB,SAAS,CAACiC,SAAS,CAACF,KAAK,CAAChB,IAAI,EAAEO,EAAE,CAAC;;MAEtD,MAAMS,KAAK;;IAGf,MAAMpD,QAAQ,GAAG6D,WAAW,CAAC,GAAAE,SAAO,CAAC;IACrC,OAAO7D,QAAQ,CAACmB,SAAS,CAACuD,oBAAoB,CAAC5E,QAAQ,EAAE0E,MAAM,CAAC;EACpE,CAAC;EAED,MAAMjB,MAAM,GAAG,eAAAA,CAAA,EAAyC;IACpD,MAAMzD,QAAQ,GAAG6D,WAAW,CAAC,GAAAE,SAAO,CAAC;IACrC,IAAI/D,QAAQ,CAAC6E,QAAQ,EAAE;MAAE,OAAO,MAAM5B,UAAU,CAAC,GAAAc,SAAO,CAAC;;IACzD,OAAO,MAAMR,IAAI,CAAC,GAAAQ,SAAO,CAAC;EAC9B,CAAC;EAED,IAAA9E,UAAA,CAAAmB,gBAAgB,EAAMqD,MAAM,EAAE;IAC1BqB,IAAI,EAAE5E,QAAQ,CAACmB,SAAS,CAAC0D,eAAe,CAACnB,GAAG,CAAC;IAC7CF,SAAS,EAAExD,QAAQ;IAAE+D,IAAI,EAAEL,GAAG;IAE9BC,WAAW;IAEXpE,WAAW;IACXiD,mBAAmB;IACnBa,IAAI;IAAEN,UAAU;IAAE0B;GACrB,CAAC;EAEF;EACAL,MAAM,CAACU,cAAc,CAACvB,MAAM,EAAE,UAAU,EAAE;IACtCwB,YAAY,EAAE,KAAK;IACnBC,UAAU,EAAE,IAAI;IAChBC,GAAG,EAAEA,CAAA,KAAK;MACN,MAAMnF,QAAQ,GAAGE,QAAQ,CAACmB,SAAS,CAAC6C,WAAW,CAACN,GAAG,CAAC;MACpD,IAAA3E,UAAA,CAAAiE,MAAM,EAAClD,QAAQ,EAAE,sBAAsB,EAAE,uBAAuB,EAAE;QAC9DmD,SAAS,EAAE;OACd,CAAC;MACF,OAAOnD,QAAQ;IACnB;GACH,CAAC;EAEF,OAAoCyD,MAAM;AAC9C;AAEA,SAAS2B,iBAAiBA,CAAoClF,QAAsB,EAAE0D,GAAW;EAE7F,MAAMC,WAAW,GAAG,SAAAA,CAAA,EAAsC;IAAA,SAAAwB,KAAA,GAAAtB,SAAA,CAAAzD,MAAA,EAA1BH,IAA0B,OAAA6D,KAAA,CAAAqB,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAA1BnF,IAA0B,CAAAmF,KAAA,IAAAvB,SAAA,CAAAuB,KAAA;IAAA;IACtD,MAAMtF,QAAQ,GAAGE,QAAQ,CAACmB,SAAS,CAACkE,QAAQ,CAAC3B,GAAG,EAAEzD,IAAI,CAAC;IAEvD,IAAAlB,UAAA,CAAAiE,MAAM,EAAClD,QAAQ,EAAE,sBAAsB,EAAE,uBAAuB,EAAE;MAC9DmD,SAAS,EAAE;KACd,CAAC;IAEF,OAAOnD,QAAQ;EACnB,CAAC;EAED,MAAMyD,MAAM,GAAG,SAAAA,CAAA,EAAuC;IAAA,SAAA+B,KAAA,GAAAzB,SAAA,CAAAzD,MAAA,EAA3BH,IAA2B,OAAA6D,KAAA,CAAAwB,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAA3BtF,IAA2B,CAAAsF,KAAA,IAAA1B,SAAA,CAAA0B,KAAA;IAAA;IAClD,OAAO,IAAI3F,mBAAmB,CAACI,QAAQ,EAAE2D,WAAW,CAAC,GAAG1D,IAAI,CAAC,EAAEA,IAAI,CAAC;EACxE,CAAC;EAED,IAAAlB,UAAA,CAAAmB,gBAAgB,EAAMqD,MAAM,EAAE;IAC1BqB,IAAI,EAAE5E,QAAQ,CAACmB,SAAS,CAACqE,YAAY,CAAC9B,GAAG,CAAC;IAC1CF,SAAS,EAAExD,QAAQ;IAAE+D,IAAI,EAAEL,GAAG;IAE9BC;GACH,CAAC;EAEF;EACAS,MAAM,CAACU,cAAc,CAACvB,MAAM,EAAE,UAAU,EAAE;IACtCwB,YAAY,EAAE,KAAK;IACnBC,UAAU,EAAE,IAAI;IAChBC,GAAG,EAAEA,CAAA,KAAK;MACN,MAAMnF,QAAQ,GAAGE,QAAQ,CAACmB,SAAS,CAACkE,QAAQ,CAAC3B,GAAG,CAAC;MAEjD,IAAA3E,UAAA,CAAAiE,MAAM,EAAClD,QAAQ,EAAE,sBAAsB,EAAE,uBAAuB,EAAE;QAC9DmD,SAAS,EAAE;OACd,CAAC;MAEF,OAAOnD,QAAQ;IACnB;GACH,CAAC;EAEF,OAAkCyD,MAAM;AAC5C;AAUA;AACA;AACA;AACA;AAEA,MAAMkC,QAAQ,GAAGC,MAAM,CAACC,GAAG,CAAC,0BAA0B,CAAC;AAUvD,MAAMC,cAAc,GAAoC,IAAIC,OAAO,EAAE;AAErE,SAASC,WAAWA,CAAC9F,QAAsB,EAAE+F,MAAgB;EACzDH,cAAc,CAACI,GAAG,CAAChG,QAAQ,CAACyF,QAAQ,CAAC,EAAEM,MAAM,CAAC;AAClD;AAEA,SAASE,WAAWA,CAACjG,QAAsB;EACvC,OAAO4F,cAAc,CAACX,GAAG,CAACjF,QAAQ,CAACyF,QAAQ,CAAC,CAAa;AAC7D;AAEA,SAASS,UAAUA,CAAC9G,KAAU;EAC1B,OAAQA,KAAK,IAAI,OAAOA,KAAM,KAAK,QAAQ,IAAK,gBAAgB,IAAIA,KAAM,IACvE,OAAOA,KAAK,CAACiC,cAAe,KAAK,UAAW,IAAIjC,KAAK,CAACU,QAAQ;AACrE;AAEA,eAAeqG,UAAUA,CAACnG,QAAsB,EAAEoG,KAAwB;EACtE,IAAIC,MAA4C;EAChD,IAAIvG,QAAQ,GAAyB,IAAI;EAEzC;EACA;EAEA,IAAIgE,KAAK,CAACwC,OAAO,CAACF,KAAK,CAAC,EAAE;IACtB,MAAMG,YAAY,GAAG,SAAAA,CAAS3B,IAAY;MACtC,IAAI,IAAA7F,UAAA,CAAAyH,WAAW,EAAC5B,IAAI,EAAE,EAAE,CAAC,EAAE;QAAE,OAAOA,IAAI;;MACxC,MAAM9E,QAAQ,GAAGE,QAAQ,CAACmB,SAAS,CAACkE,QAAQ,CAACT,IAAI,CAAC;MAClD,IAAA7F,UAAA,CAAAgD,cAAc,EAACjC,QAAQ,EAAE,kBAAkB,EAAE,MAAM,EAAE8E,IAAI,CAAC;MAC1D,OAAO9E,QAAQ,CAAC2G,SAAS;IAC7B,CAAC;IAED;IACAJ,MAAM,GAAGD,KAAK,CAACxF,GAAG,CAAE8F,CAAC,IAAI;MACrB,IAAIA,CAAC,IAAI,IAAI,EAAE;QAAE,OAAO,IAAI;;MAC5B,IAAI5C,KAAK,CAACwC,OAAO,CAACI,CAAC,CAAC,EAAE;QAAE,OAAOA,CAAC,CAAC9F,GAAG,CAAC2F,YAAY,CAAC;;MAClD,OAAOA,YAAY,CAACG,CAAC,CAAC;IAC1B,CAAC,CAAC;GAEL,MAAM,IAAIN,KAAK,KAAK,GAAG,EAAE;IACtBC,MAAM,GAAG,CAAE,IAAI,CAAE;GAEpB,MAAM,IAAI,OAAOD,KAAM,KAAK,QAAQ,EAAE;IACnC,IAAI,IAAArH,UAAA,CAAAyH,WAAW,EAACJ,KAAK,EAAE,EAAE,CAAC,EAAE;MACxB;MACAC,MAAM,GAAG,CAAED,KAAK,CAAE;KACrB,MAAM;MACJ;MACCtG,QAAQ,GAAGE,QAAQ,CAACmB,SAAS,CAACkE,QAAQ,CAACe,KAAK,CAAC;MAC7C,IAAArH,UAAA,CAAAgD,cAAc,EAACjC,QAAQ,EAAE,kBAAkB,EAAE,OAAO,EAAEsG,KAAK,CAAC;MAC5DC,MAAM,GAAG,CAAEvG,QAAQ,CAAC2G,SAAS,CAAE;;GAGtC,MAAM,IAAIP,UAAU,CAACE,KAAK,CAAC,EAAE;IAC1B;IACAC,MAAM,GAAG,MAAMD,KAAK,CAAC/E,cAAc,EAAE;GAExC,MAAM,IAAI,UAAU,IAAI+E,KAAK,EAAE;IAC5B;IACAtG,QAAQ,GAAGsG,KAAK,CAACtG,QAAQ;IACzBuG,MAAM,GAAG,CAAEvG,QAAQ,CAAC2G,SAAS,CAAE;GAElC,MAAM;IACH,IAAA1H,UAAA,CAAAgD,cAAc,EAAC,KAAK,EAAE,oBAAoB,EAAE,OAAO,EAAEqE,KAAK,CAAC;;EAG/D;EACAC,MAAM,GAAGA,MAAM,CAACzF,GAAG,CAAE+F,CAAC,IAAI;IACtB,IAAIA,CAAC,IAAI,IAAI,EAAE;MAAE,OAAO,IAAI;;IAC5B,IAAI7C,KAAK,CAACwC,OAAO,CAACK,CAAC,CAAC,EAAE;MAClB,MAAMC,KAAK,GAAG9C,KAAK,CAAC3B,IAAI,CAAC,IAAI0E,GAAG,CAACF,CAAC,CAAC/F,GAAG,CAAE+F,CAAC,IAAKA,CAAC,CAACG,WAAW,EAAE,CAAC,CAAC,CAACf,MAAM,EAAE,CAAC;MACzE,IAAIa,KAAK,CAACxG,MAAM,KAAK,CAAC,EAAE;QAAE,OAAOwG,KAAK,CAAC,CAAC,CAAC;;MACzCA,KAAK,CAACG,IAAI,EAAE;MACZ,OAAOH,KAAK;;IAEhB,OAAOD,CAAC,CAACG,WAAW,EAAE;EAC1B,CAAC,CAAC;EAEF,MAAME,GAAG,GAAGX,MAAM,CAACzF,GAAG,CAAE+F,CAAC,IAAI;IACzB,IAAIA,CAAC,IAAI,IAAI,EAAE;MAAE,OAAO,MAAM;;IAC9B,IAAI7C,KAAK,CAACwC,OAAO,CAACK,CAAC,CAAC,EAAE;MAAE,OAAOA,CAAC,CAACM,IAAI,CAAC,GAAG,CAAC;;IAC1C,OAAON,CAAC;EACZ,CAAC,CAAC,CAACM,IAAI,CAAC,GAAG,CAAC;EAEZ,OAAO;IAAEnH,QAAQ;IAAEkH,GAAG;IAAEX;EAAM,CAAE;AACpC;AAEA,eAAea,MAAMA,CAAClH,QAAsB,EAAEoG,KAAwB;EAClE,MAAM;IAAEe;EAAI,CAAE,GAAGlB,WAAW,CAACjG,QAAQ,CAAC;EACtC,OAAOmH,IAAI,CAAClC,GAAG,CAAC,CAAC,MAAMkB,UAAU,CAACnG,QAAQ,EAAEoG,KAAK,CAAC,EAAEY,GAAG,CAAC,IAAI,IAAI;AACpE;AAEA,eAAeI,MAAMA,CAACpH,QAAsB,EAAEiD,SAAiB,EAAEmD,KAAwB;EACrF;EACA,MAAM7E,QAAQ,GAAGC,WAAW,CAACxB,QAAQ,CAACM,MAAM,CAAC;EAC7C,IAAAvB,UAAA,CAAAiE,MAAM,EAACzB,QAAQ,EAAE,8CAA8C,EAC3D,uBAAuB,EAAE;IAAE0B;EAAS,CAAE,CAAC;EAE3C,MAAM;IAAEnD,QAAQ;IAAEkH,GAAG;IAAEX;EAAM,CAAE,GAAG,MAAMF,UAAU,CAACnG,QAAQ,EAAEoG,KAAK,CAAC;EAEnE,MAAM;IAAEiB,IAAI;IAAEF;EAAI,CAAE,GAAGlB,WAAW,CAACjG,QAAQ,CAAC;EAE5C,IAAIsH,GAAG,GAAGH,IAAI,CAAClC,GAAG,CAAC+B,GAAG,CAAC;EACvB,IAAI,CAACM,GAAG,EAAE;IACN,MAAMC,OAAO,GAA0BF,IAAI,GAAGA,IAAI,GAAErH,QAAS;IAC7D,MAAMH,MAAM,GAAG;MAAE0H,OAAO;MAAElB;IAAM,CAAE;IAClC,MAAMmB,QAAQ,GAAIC,GAAQ,IAAI;MAC1B,IAAIC,aAAa,GAAG5H,QAAQ;MAC5B,IAAI4H,aAAa,IAAI,IAAI,EAAE;QACvB,IAAI;UACAA,aAAa,GAAG1H,QAAQ,CAACmB,SAAS,CAACkE,QAAQ,CAACoC,GAAG,CAACpB,MAAM,CAAC,CAAC,CAAC,CAAC;SAC7D,CAAC,OAAOnD,KAAK,EAAE;;MAGpB;MAEA,IAAIwE,aAAa,EAAE;QACf,MAAMC,cAAc,GAAGD,aAAa;QACpC,MAAMzH,IAAI,GAAGH,QAAQ,GAAGE,QAAQ,CAACmB,SAAS,CAACyG,cAAc,CAAC9H,QAAQ,EAAE2H,GAAG,CAACvF,IAAI,EAAEuF,GAAG,CAACpB,MAAM,CAAC,GAAE,EAAG;QAC9FwB,IAAI,CAAC7H,QAAQ,EAAEoG,KAAK,EAAEnG,IAAI,EAAGuH,QAAyB,IAAI;UACtD,OAAO,IAAIxI,aAAA,CAAA8I,oBAAoB,CAAC9H,QAAQ,EAAEwH,QAAQ,EAAEpB,KAAK,EAAEuB,cAAc,EAAEF,GAAG,CAAC;QACnF,CAAC,CAAC;OACL,MAAM;QACHI,IAAI,CAAC7H,QAAQ,EAAEoG,KAAK,EAAE,EAAG,EAAGoB,QAAyB,IAAI;UACrD,OAAO,IAAIxI,aAAA,CAAA+I,2BAA2B,CAAC/H,QAAQ,EAAEwH,QAAQ,EAAEpB,KAAK,EAAEqB,GAAG,CAAC;QAC1E,CAAC,CAAC;;IAEV,CAAC;IAED,IAAIO,QAAQ,GAAwB,EAAG;IACvC,MAAMC,KAAK,GAAGA,CAAA,KAAK;MACf,IAAID,QAAQ,CAAC5H,MAAM,EAAE;QAAE;;MACvB4H,QAAQ,CAACE,IAAI,CAAC3G,QAAQ,CAAC4G,EAAE,CAACtI,MAAM,EAAE2H,QAAQ,CAAC,CAAC;IAChD,CAAC;IAED,MAAMY,IAAI,GAAG,MAAAA,CAAA,KAAW;MACpB,IAAIJ,QAAQ,CAAC5H,MAAM,IAAI,CAAC,EAAE;QAAE;;MAE5B,IAAIiI,OAAO,GAAGL,QAAQ;MACtBA,QAAQ,GAAG,EAAG;MACd,MAAMtH,OAAO,CAACC,GAAG,CAAC0H,OAAO,CAAC;MAC1B9G,QAAQ,CAAC+G,GAAG,CAACzI,MAAM,EAAE2H,QAAQ,CAAC;IAClC,CAAC;IAEDF,GAAG,GAAG;MAAEN,GAAG;MAAEuB,SAAS,EAAE,EAAG;MAAEN,KAAK;MAAEG;IAAI,CAAE;IAC1CjB,IAAI,CAACnB,GAAG,CAACgB,GAAG,EAAEM,GAAG,CAAC;;EAEtB,OAAOA,GAAG;AACd;AAEA;AACA;AACA;AACA,IAAIkB,QAAQ,GAAiB9H,OAAO,CAAC+H,OAAO,EAAE;AAI9C,eAAeC,KAAKA,CAAC1I,QAAsB,EAAEoG,KAAwB,EAAEnG,IAAgB,EAAE0I,WAA+B;EACpH,MAAMH,QAAQ;EAEd,MAAMlB,GAAG,GAAG,MAAMJ,MAAM,CAAClH,QAAQ,EAAEoG,KAAK,CAAC;EACzC,IAAI,CAACkB,GAAG,EAAE;IAAE,OAAO,KAAK;;EAExB,MAAMsB,KAAK,GAAGtB,GAAG,CAACiB,SAAS,CAACnI,MAAM;EAClCkH,GAAG,CAACiB,SAAS,GAAGjB,GAAG,CAACiB,SAAS,CAAC1I,MAAM,CAACgJ,IAAA,IAAuB;IAAA,IAAtB;MAAErB,QAAQ;MAAEsB;IAAI,CAAE,GAAAD,IAAA;IACpD,MAAME,QAAQ,GAAGjF,KAAK,CAAC3B,IAAI,CAAClC,IAAI,CAAC;IACjC,IAAI0I,WAAW,EAAE;MACbI,QAAQ,CAACb,IAAI,CAACS,WAAW,CAACG,IAAI,GAAG,IAAI,GAAEtB,QAAQ,CAAC,CAAC;;IAErD,IAAI;MACAA,QAAQ,CAACnI,IAAI,CAACW,QAAQ,EAAE,GAAG+I,QAAQ,CAAC;KACvC,CAAC,OAAO7F,KAAK,EAAE;IAChB,OAAO,CAAC4F,IAAI;EAChB,CAAC,CAAC;EACF,OAAQF,KAAK,GAAG,CAAC;AACrB;AAEA,eAAef,IAAIA,CAAC7H,QAAsB,EAAEoG,KAAwB,EAAEnG,IAAgB,EAAE0I,WAA+B;EACnH,IAAI;IACA,MAAMH,QAAQ;GACjB,CAAC,OAAOtF,KAAK,EAAE;EAEhB,MAAM8F,aAAa,GAAGN,KAAK,CAAC1I,QAAQ,EAAEoG,KAAK,EAAEnG,IAAI,EAAE0I,WAAW,CAAC;EAC/DH,QAAQ,GAAGQ,aAAa;EACxB,OAAO,MAAMA,aAAa;AAC9B;AAEA,MAAMC,cAAc,GAAG,CAAE,MAAM,CAAE;AACjC,MAAaC,YAAY;EACZC,MAAM;EACNhI,SAAS;EACTb,MAAM;EAEN8I,OAAO;EAEP,CAAC3D,QAAQ;EAET3C,QAAQ;EAEjB/C,YAAYoJ,MAA4B,EAAEE,GAA6B,EAAE/I,MAA8B,EAAEgJ,SAAsC;IAC3I,IAAIhJ,MAAM,IAAI,IAAI,EAAE;MAAEA,MAAM,GAAG,IAAI;;IACnC,MAAMqC,KAAK,GAAGhE,UAAA,CAAA4K,SAAS,CAACpH,IAAI,CAACkH,GAAG,CAAC;IACjC,IAAAtK,UAAA,CAAAmB,gBAAgB,EAAe,IAAI,EAAE;MAAEiJ,MAAM;MAAE7I,MAAM;MAAEa,SAAS,EAAEwB;IAAK,CAAE,CAAC;IAE1EyB,MAAM,CAACU,cAAc,CAAC,IAAI,EAAEW,QAAQ,EAAE;MAAErG,KAAK,EAAE;IAAG,CAAE,CAAC;IAErD,IAAIoK,WAAW;IACf,IAAInC,IAAI,GAAG,IAAI;IAEf,IAAIoC,QAAQ,GAAuC,IAAI;IACvD,IAAIH,SAAS,EAAE;MACX,MAAM/H,QAAQ,GAAGC,WAAW,CAAClB,MAAM,CAAC;MACpC;MACA;MACAmJ,QAAQ,GAAG,IAAIzK,aAAA,CAAAsE,2BAA2B,CAAC,IAAI,CAACnC,SAAS,EAAYI,QAAQ,EAAE+H,SAAS,CAAC;;IAG7F,IAAInC,IAAI,GAAG,IAAIuC,GAAG,EAAE;IAEpB;IACA,IAAI,OAAOP,MAAO,KAAK,QAAQ,EAAE;MAC7B,IAAI,IAAApK,UAAA,CAAAyH,WAAW,EAAC2C,MAAM,CAAC,EAAE;QACrB9B,IAAI,GAAG8B,MAAM;QACbK,WAAW,GAAG9I,OAAO,CAAC+H,OAAO,CAACU,MAAM,CAAC;OAExC,MAAM;QACH,MAAM3I,QAAQ,GAAGD,SAAS,CAACD,MAAM,EAAE,aAAa,CAAC;QACjD,IAAI,CAACd,UAAU,CAACgB,QAAQ,CAAC,EAAE;UACvB,MAAM,IAAAzB,UAAA,CAAAqE,SAAS,EAAC,kDAAkD,EAAE,uBAAuB,EAAE;YACzFH,SAAS,EAAE;WACd,CAAC;;QAGNuG,WAAW,GAAGhJ,QAAQ,CAACf,WAAW,CAAC0J,MAAM,CAAC,CAACQ,IAAI,CAAEtC,IAAI,IAAI;UACrD,IAAIA,IAAI,IAAI,IAAI,EAAE;YAAE,MAAM,IAAIhH,KAAK,CAAC,MAAM,CAAC;;UAC3C4F,WAAW,CAAC,IAAI,CAAC,CAACoB,IAAI,GAAGA,IAAI;UAC7B,OAAOA,IAAI;QACf,CAAC,CAAC;;KAET,MAAM;MACHmC,WAAW,GAAGL,MAAM,CAACzG,UAAU,EAAE,CAACiH,IAAI,CAAEtC,IAAI,IAAI;QAC5C,IAAIA,IAAI,IAAI,IAAI,EAAE;UAAE,MAAM,IAAIhH,KAAK,CAAC,MAAM,CAAC;;QAC3C4F,WAAW,CAAC,IAAI,CAAC,CAACoB,IAAI,GAAGA,IAAI;QAC7B,OAAOA,IAAI;MACf,CAAC,CAAC;;IAGN;IACAvB,WAAW,CAAC,IAAI,EAAE;MAAE0D,WAAW;MAAEnC,IAAI;MAAEoC,QAAQ;MAAEtC;IAAI,CAAE,CAAC;IAExD;IACA,MAAMiC,OAAO,GAAG,IAAIQ,KAAK,CAAC,EAAG,EAAE;MAC3B3E,GAAG,EAAEA,CAACkE,MAAM,EAAEU,KAAK,EAAEC,QAAQ,KAAI;QAC7B;QACA,IAAIb,cAAc,CAAChH,OAAO,CAAS4H,KAAK,CAAC,IAAI,CAAC,EAAE;UAC5C,OAAOE,OAAO,CAAC9E,GAAG,CAACkE,MAAM,EAAEU,KAAK,EAAEC,QAAQ,CAAC;;QAG/C,MAAME,IAAI,GAAGC,MAAM,CAACJ,KAAK,CAAC;QAE1B,MAAMrF,MAAM,GAAG,IAAI,CAACa,QAAQ,CAAC2E,IAAI,CAAC;QAClC,IAAIxF,MAAM,EAAE;UAAE,OAAOA,MAAM;;QAE3B,MAAM,IAAInE,KAAK,CAAC,2BAA4B2J,IAAK,EAAE,CAAC;MACxD,CAAC;MACDE,GAAG,EAAEA,CAACf,MAAM,EAAEa,IAAI,KAAI;QAClB;QACA,IAAIf,cAAc,CAAChH,OAAO,CAAS+H,IAAI,CAAC,IAAI,CAAC,EAAE;UAC3C,OAAOD,OAAO,CAACG,GAAG,CAACf,MAAM,EAAEa,IAAI,CAAC;;QAGpC,OAAOD,OAAO,CAACG,GAAG,CAACf,MAAM,EAAEa,IAAI,CAAC,IAAI,IAAI,CAAC7I,SAAS,CAACgJ,QAAQ,CAACF,MAAM,CAACD,IAAI,CAAC,CAAC;MAC7E;KACH,CAAC;IACF,IAAAjL,UAAA,CAAAmB,gBAAgB,EAAe,IAAI,EAAE;MAAEkJ;IAAO,CAAE,CAAC;IAEjD,IAAArK,UAAA,CAAAmB,gBAAgB,EAAe,IAAI,EAAE;MACjC4C,QAAQ,EAAIH,KAAK,CAACE,OAAO,IAAIF,KAAK,CAACG,QAAQ,GAAKP,oBAAoB,CAAC,IAAI,CAAC,GAAG;KAChF,CAAC;IAEF;IACA,OAAO,IAAIqH,KAAK,CAAC,IAAI,EAAE;MACnB3E,GAAG,EAAEA,CAACkE,MAAM,EAAEU,KAAK,EAAEC,QAAQ,KAAI;QAC7B,IAAID,KAAK,IAAIV,MAAM,IAAIF,cAAc,CAAChH,OAAO,CAAS4H,KAAK,CAAC,IAAI,CAAC,EAAE;UAC/D,OAAOE,OAAO,CAAC9E,GAAG,CAACkE,MAAM,EAAEU,KAAK,EAAEC,QAAQ,CAAC;;QAG/C,MAAME,IAAI,GAAGC,MAAM,CAACJ,KAAK,CAAC;QAE1B,MAAMrF,MAAM,GAAG2E,MAAM,CAACnF,WAAW,CAACgG,IAAI,CAAC;QACvC,IAAIxF,MAAM,EAAE;UAAE,OAAOA,MAAM;;QAE3B,MAAM,IAAInE,KAAK,CAAC,4BAA6B2J,IAAK,EAAE,CAAC;MACzD,CAAC;MACDE,GAAG,EAAEA,CAACf,MAAM,EAAEa,IAAI,KAAI;QAClB,IAAIA,IAAI,IAAIb,MAAM,IAAIF,cAAc,CAAChH,OAAO,CAAS+H,IAAI,CAAC,IAAI,CAAC,EAAE;UAC7D,OAAOD,OAAO,CAACG,GAAG,CAACf,MAAM,EAAEa,IAAI,CAAC;;QAGpC,OAAOb,MAAM,CAAChI,SAAS,CAACiJ,WAAW,CAACH,MAAM,CAACD,IAAI,CAAC,CAAC;MACrD;KACH,CAAC;EAEN;EAEAK,OAAOA,CAAC/J,MAA6B;IACjC,OAAO,IAAI4I,YAAY,CAAC,IAAI,CAACC,MAAM,EAAE,IAAI,CAAChI,SAAS,EAAEb,MAAM,CAAC;EAChE;EAEA,MAAMoC,UAAUA,CAAA;IAAsB,OAAO,MAAMuD,WAAW,CAAC,IAAI,CAAC,CAACuD,WAAW;EAAE;EAElF,MAAMc,eAAeA,CAAA;IACjB,MAAM/I,QAAQ,GAAGC,WAAW,CAAC,IAAI,CAAClB,MAAM,CAAC;IACzC,IAAAvB,UAAA,CAAAiE,MAAM,EAACzB,QAAQ,EAAE,mCAAmC,EAChD,uBAAuB,EAAE;MAAE0B,SAAS,EAAE;IAAiB,CAAE,CAAC;IAE9D,MAAMsH,IAAI,GAAG,MAAMhJ,QAAQ,CAACiJ,OAAO,CAAC,MAAM,IAAI,CAAC9H,UAAU,EAAE,CAAC;IAC5D,IAAI6H,IAAI,KAAK,IAAI,EAAE;MAAE,OAAO,IAAI;;IAChC,OAAOA,IAAI;EACf;EAEA,MAAME,iBAAiBA,CAAA;IACnB;IACA,MAAMhB,QAAQ,GAAG,IAAI,CAACiB,qBAAqB,EAAE;IAC7C,IAAIjB,QAAQ,EAAE;MACV,MAAMA,QAAQ,CAACkB,IAAI,EAAE;MACrB,OAAO,IAAI;;IAGf;IACA,MAAMJ,IAAI,GAAG,MAAM,IAAI,CAACD,eAAe,EAAE;IACzC,IAAIC,IAAI,IAAI,IAAI,EAAE;MAAE,OAAO,IAAI;;IAE/B;IACA,MAAMhJ,QAAQ,GAAGC,WAAW,CAAC,IAAI,CAAClB,MAAM,CAAC;IACzC,IAAAvB,UAAA,CAAAiE,MAAM,EAACzB,QAAQ,IAAI,IAAI,EAAE,4CAA4C,EACjE,uBAAuB,EAAE;MAAE0B,SAAS,EAAE;IAAmB,CAAE,CAAC;IAEhE,OAAO,IAAIvC,OAAO,CAAC,CAAC+H,OAAO,EAAEmC,MAAM,KAAI;MACnC,MAAMC,SAAS,GAAG,MAAAA,CAAA,KAAW;QACzB,IAAI;UACA,MAAMN,IAAI,GAAG,MAAM,IAAI,CAACD,eAAe,EAAE;UACzC,IAAIC,IAAI,IAAI,IAAI,EAAE;YAAE,OAAO9B,OAAO,CAAC,IAAI,CAAC;;UACxClH,QAAQ,CAACuH,IAAI,CAAC,OAAO,EAAE+B,SAAS,CAAC;SACpC,CAAC,OAAO3H,KAAK,EAAE;UACZ0H,MAAM,CAAC1H,KAAK,CAAC;;MAErB,CAAC;MACD2H,SAAS,EAAE;IACf,CAAC,CAAC;EACN;EAEAH,qBAAqBA,CAAA;IACjB,OAAOzE,WAAW,CAAC,IAAI,CAAC,CAACwD,QAAQ;EACrC;EAEAzF,WAAWA,CAA4CN,GAA8B;IACjF,IAAI,OAAOA,GAAI,KAAK,QAAQ,EAAE;MAAEA,GAAG,GAAGA,GAAG,CAACoH,MAAM,EAAE;;IAClD,MAAMC,IAAI,GAAGtH,kBAAkB,CAAC,IAAI,EAAEC,GAAG,CAAC;IAC1C,OAAUqH,IAAI;EAClB;EAEA1F,QAAQA,CAAC3B,GAA2B;IAChC,IAAI,OAAOA,GAAI,KAAK,QAAQ,EAAE;MAAEA,GAAG,GAAGA,GAAG,CAACoH,MAAM,EAAE;;IAClD,OAAO5F,iBAAiB,CAAC,IAAI,EAAExB,GAAG,CAAC;EACvC;EAEA,MAAMsH,gBAAgBA,CAACC,IAAY;IAC/B;IACA,MAAM,IAAI5K,KAAK,CAAC,OAAO,CAAC;EAC5B;EAEA,MAAM6K,WAAWA,CAAC9E,KAAwB,EAAE+E,SAAoB,EAAEC,OAAkB;IAChF,IAAID,SAAS,IAAI,IAAI,EAAE;MAAEA,SAAS,GAAG,CAAC;;IACtC,IAAIC,OAAO,IAAI,IAAI,EAAE;MAAEA,OAAO,GAAG,QAAQ;;IACzC,MAAM;MAAE/D,IAAI;MAAEmC;IAAW,CAAE,GAAGvD,WAAW,CAAC,IAAI,CAAC;IAC/C,MAAMsB,OAAO,GAAIF,IAAI,GAAGA,IAAI,GAAG,MAAMmC,WAAa;IAClD,MAAM;MAAE1J,QAAQ;MAAEuG;IAAM,CAAE,GAAG,MAAMF,UAAU,CAAC,IAAI,EAAEC,KAAK,CAAC;IAC1D,MAAMvG,MAAM,GAAG;MAAE0H,OAAO;MAAElB,MAAM;MAAE8E,SAAS;MAAEC;IAAO,CAAE;IAEtD,MAAM7J,QAAQ,GAAGC,WAAW,CAAC,IAAI,CAAClB,MAAM,CAAC;IACzC,IAAAvB,UAAA,CAAAiE,MAAM,EAACzB,QAAQ,EAAE,0CAA0C,EACvD,uBAAuB,EAAE;MAAE0B,SAAS,EAAE;IAAa,CAAE,CAAC;IAE1D,OAAO,CAAC,MAAM1B,QAAQ,CAAC8J,OAAO,CAACxL,MAAM,CAAC,EAAEe,GAAG,CAAE6G,GAAG,IAAI;MAChD,IAAIC,aAAa,GAAG5H,QAAQ;MAC5B,IAAI4H,aAAa,IAAI,IAAI,EAAE;QACvB,IAAI;UACAA,aAAa,GAAG,IAAI,CAACvG,SAAS,CAACkE,QAAQ,CAACoC,GAAG,CAACpB,MAAM,CAAC,CAAC,CAAC,CAAC;SACzD,CAAC,OAAOnD,KAAK,EAAE;;MAGpB,IAAIwE,aAAa,EAAE;QACf,OAAO,IAAI1I,aAAA,CAAAsM,QAAQ,CAAC7D,GAAG,EAAE,IAAI,CAACtG,SAAS,EAAEuG,aAAa,CAAC;OAC1D,MAAM;QACH,OAAO,IAAI5I,aAAA,CAAAyM,GAAG,CAAC9D,GAAG,EAAElG,QAAQ,CAAC;;IAErC,CAAC,CAAC;EACN;EAEA,MAAM4G,EAAEA,CAAC/B,KAAwB,EAAEoB,QAAkB;IACjD,MAAMF,GAAG,GAAG,MAAMF,MAAM,CAAC,IAAI,EAAE,IAAI,EAAEhB,KAAK,CAAC;IAC3CkB,GAAG,CAACiB,SAAS,CAACL,IAAI,CAAC;MAAEV,QAAQ;MAAEsB,IAAI,EAAE;IAAK,CAAE,CAAC;IAC7CxB,GAAG,CAACW,KAAK,EAAE;IACX,OAAO,IAAI;EACf;EAEA,MAAMa,IAAIA,CAAC1C,KAAwB,EAAEoB,QAAkB;IACnD,MAAMF,GAAG,GAAG,MAAMF,MAAM,CAAC,IAAI,EAAE,MAAM,EAAEhB,KAAK,CAAC;IAC7CkB,GAAG,CAACiB,SAAS,CAACL,IAAI,CAAC;MAAEV,QAAQ;MAAEsB,IAAI,EAAE;IAAI,CAAE,CAAC;IAC5CxB,GAAG,CAACW,KAAK,EAAE;IACX,OAAO,IAAI;EACf;EAEA,MAAMJ,IAAIA,CAACzB,KAAwB,EAAqB;IAAA,SAAAoF,KAAA,GAAA3H,SAAA,CAAAzD,MAAA,EAAhBH,IAAgB,OAAA6D,KAAA,CAAA0H,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAhBxL,IAAgB,CAAAwL,KAAA,QAAA5H,SAAA,CAAA4H,KAAA;IAAA;IACpD,OAAO,MAAM5D,IAAI,CAAC,IAAI,EAAEzB,KAAK,EAAEnG,IAAI,EAAE,IAAI,CAAC;EAC9C;EAEA,MAAMyL,aAAaA,CAACtF,KAAyB;IACzC,IAAIA,KAAK,EAAE;MACP,MAAMkB,GAAG,GAAG,MAAMJ,MAAM,CAAC,IAAI,EAAEd,KAAK,CAAC;MACrC,IAAI,CAACkB,GAAG,EAAE;QAAE,OAAO,CAAC;;MACpB,OAAOA,GAAG,CAACiB,SAAS,CAACnI,MAAM;;IAG/B,MAAM;MAAE+G;IAAI,CAAE,GAAGlB,WAAW,CAAC,IAAI,CAAC;IAElC,IAAI0F,KAAK,GAAG,CAAC;IACb,KAAK,MAAM;MAAEpD;IAAS,CAAE,IAAIpB,IAAI,CAACpB,MAAM,EAAE,EAAE;MACvC4F,KAAK,IAAIpD,SAAS,CAACnI,MAAM;;IAE7B,OAAOuL,KAAK;EAChB;EAEA,MAAMpD,SAASA,CAACnC,KAAyB;IACrC,IAAIA,KAAK,EAAE;MACP,MAAMkB,GAAG,GAAG,MAAMJ,MAAM,CAAC,IAAI,EAAEd,KAAK,CAAC;MACrC,IAAI,CAACkB,GAAG,EAAE;QAAE,OAAO,EAAG;;MACtB,OAAOA,GAAG,CAACiB,SAAS,CAAC3H,GAAG,CAACgL,KAAA;QAAA,IAAC;UAAEpE;QAAQ,CAAE,GAAAoE,KAAA;QAAA,OAAKpE,QAAQ;MAAA,EAAC;;IAGxD,MAAM;MAAEL;IAAI,CAAE,GAAGlB,WAAW,CAAC,IAAI,CAAC;IAElC,IAAIzB,MAAM,GAAoB,EAAG;IACjC,KAAK,MAAM;MAAE+D;IAAS,CAAE,IAAIpB,IAAI,CAACpB,MAAM,EAAE,EAAE;MACvCvB,MAAM,GAAGA,MAAM,CAACqH,MAAM,CAACtD,SAAS,CAAC3H,GAAG,CAACkL,KAAA;QAAA,IAAC;UAAEtE;QAAQ,CAAE,GAAAsE,KAAA;QAAA,OAAKtE,QAAQ;MAAA,EAAC,CAAC;;IAErE,OAAOhD,MAAM;EACjB;EAEA,MAAM8D,GAAGA,CAAClC,KAAwB,EAAEoB,QAAmB;IACnD,MAAMF,GAAG,GAAG,MAAMJ,MAAM,CAAC,IAAI,EAAEd,KAAK,CAAC;IACrC,IAAI,CAACkB,GAAG,EAAE;MAAE,OAAO,IAAI;;IAEvB,IAAIE,QAAQ,EAAE;MACV,MAAM1G,KAAK,GAAGwG,GAAG,CAACiB,SAAS,CAAC3H,GAAG,CAACmL,KAAA;QAAA,IAAC;UAAEvE;QAAQ,CAAE,GAAAuE,KAAA;QAAA,OAAKvE,QAAQ;MAAA,EAAC,CAACvF,OAAO,CAACuF,QAAQ,CAAC;MAC7E,IAAI1G,KAAK,IAAI,CAAC,EAAE;QAAEwG,GAAG,CAACiB,SAAS,CAACyD,MAAM,CAAClL,KAAK,EAAE,CAAC,CAAC;;;IAGpD,IAAI0G,QAAQ,IAAI,IAAI,IAAIF,GAAG,CAACiB,SAAS,CAACnI,MAAM,KAAK,CAAC,EAAE;MAChDkH,GAAG,CAACc,IAAI,EAAE;MACVnC,WAAW,CAAC,IAAI,CAAC,CAACkB,IAAI,CAAC8E,MAAM,CAAC3E,GAAG,CAACN,GAAG,CAAC;;IAG1C,OAAO,IAAI;EACf;EAEA,MAAMkF,kBAAkBA,CAAC9F,KAAyB;IAC9C,IAAIA,KAAK,EAAE;MACP,MAAMkB,GAAG,GAAG,MAAMJ,MAAM,CAAC,IAAI,EAAEd,KAAK,CAAC;MACrC,IAAI,CAACkB,GAAG,EAAE;QAAE,OAAO,IAAI;;MACvBA,GAAG,CAACc,IAAI,EAAE;MACVnC,WAAW,CAAC,IAAI,CAAC,CAACkB,IAAI,CAAC8E,MAAM,CAAC3E,GAAG,CAACN,GAAG,CAAC;KACzC,MAAM;MACH,MAAM;QAAEG;MAAI,CAAE,GAAGlB,WAAW,CAAC,IAAI,CAAC;MAClC,KAAK,MAAM;QAAEe,GAAG;QAAEoB;MAAI,CAAE,IAAIjB,IAAI,CAACpB,MAAM,EAAE,EAAE;QACvCqC,IAAI,EAAE;QACNjB,IAAI,CAAC8E,MAAM,CAACjF,GAAG,CAAC;;;IAIxB,OAAO,IAAI;EACf;EAEA;EACA,MAAMmF,WAAWA,CAAC/F,KAAwB,EAAEoB,QAAkB;IAC1D,OAAO,MAAM,IAAI,CAACW,EAAE,CAAC/B,KAAK,EAAEoB,QAAQ,CAAC;EACzC;EAEA;EACA,MAAM4E,cAAcA,CAAChG,KAAwB,EAAEoB,QAAkB;IAC7D,OAAO,MAAM,IAAI,CAACc,GAAG,CAAClC,KAAK,EAAEoB,QAAQ,CAAC;EAC1C;EAEA,OAAO6E,UAAUA,CAAwBhD,GAAiB;IACtD,MAAMiD,cAAe,SAAQpD,YAAY;MACrCnJ,YAAYwH,OAAe,EAAsC;QAAA,IAApCjH,MAAA,GAAAuD,SAAA,CAAAzD,MAAA,QAAAyD,SAAA,QAAA0I,SAAA,GAAA1I,SAAA,MAAgC,IAAI;QAC7D,KAAK,CAAC0D,OAAO,EAAE8B,GAAG,EAAE/I,MAAM,CAAC;MAC/B;;IAEJ,OAAOgM,cAAqB;EAChC;EAEA,OAAOnK,IAAIA,CAAwBgH,MAAc,EAAEE,GAAiB,EAAE/I,MAA8B;IAChG,IAAIA,MAAM,IAAI,IAAI,EAAE;MAAEA,MAAM,GAAG,IAAI;;IACnC,MAAMN,QAAQ,GAAG,IAAI,IAAI,CAACmJ,MAAM,EAAEE,GAAG,EAAE/I,MAAM,CAAE;IAC/C,OAAON,QAAe;EAC1B;;AA/TJoC,OAAA,CAAA8G,YAAA,GAAAA,YAAA;AAkUA,SAASsD,aAAaA,CAAA;EAClB,OAAOtD,YAAmB;AAC9B;AAEA,MAAauD,QAAS,SAAQD,aAAa,EAAE;AAA7CpK,OAAA,CAAAqK,QAAA,GAAAA,QAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}