{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IpcSocketProvider = void 0;\nconst net_1 = require(\"net\");\nconst provider_socket_js_1 = require(\"./provider-socket.js\");\n// @TODO: Is this sufficient? Is this robust? Will newlines occur between\n// all payloads and only between payloads?\nfunction splitBuffer(data) {\n  const messages = [];\n  let lastStart = 0;\n  while (true) {\n    const nl = data.indexOf(10, lastStart);\n    if (nl === -1) {\n      break;\n    }\n    messages.push(data.subarray(lastStart, nl).toString().trim());\n    lastStart = nl + 1;\n  }\n  return {\n    messages,\n    remaining: data.subarray(lastStart)\n  };\n}\nclass IpcSocketProvider extends provider_socket_js_1.SocketProvider {\n  #socket;\n  get socket() {\n    return this.#socket;\n  }\n  constructor(path, network) {\n    super(network);\n    this.#socket = (0, net_1.connect)(path);\n    this.socket.on(\"ready\", async () => {\n      try {\n        await this._start();\n      } catch (error) {\n        console.log(\"failed to start IpcSocketProvider\", error);\n        // @TODO: Now what? Restart?\n      }\n    });\n\n    let response = Buffer.alloc(0);\n    this.socket.on(\"data\", data => {\n      response = Buffer.concat([response, data]);\n      const {\n        messages,\n        remaining\n      } = splitBuffer(response);\n      messages.forEach(message => {\n        this._processMessage(message);\n      });\n      response = remaining;\n    });\n    this.socket.on(\"end\", () => {\n      this.emit(\"close\");\n      this.socket.destroy();\n      this.socket.end();\n    });\n  }\n  destroy() {\n    this.socket.destroy();\n    this.socket.end();\n    super.destroy();\n  }\n  async _write(message) {\n    this.socket.write(message);\n  }\n}\nexports.IpcSocketProvider = IpcSocketProvider;","map":{"version":3,"names":["net_1","require","provider_socket_js_1","splitBuffer","data","messages","lastStart","nl","indexOf","push","subarray","toString","trim","remaining","IpcSocketProvider","SocketProvider","socket","constructor","path","network","connect","on","_start","error","console","log","response","Buffer","alloc","concat","forEach","message","_processMessage","emit","destroy","end","_write","write","exports"],"sources":["/Users/oguzhansenol/Developer/Repositories/lottery-project-interface/node_modules/ethers/src.ts/providers/provider-ipcsocket.ts"],"sourcesContent":["\nimport { connect } from \"net\";\nimport { SocketProvider } from \"./provider-socket.js\";\n\nimport type { Socket } from \"net\";\nimport type { Networkish } from \"./network.js\";\n\n\n// @TODO: Is this sufficient? Is this robust? Will newlines occur between\n// all payloads and only between payloads?\nfunction splitBuffer(data: Buffer): { messages: Array<string>, remaining: Buffer } {\n    const messages: Array<string> = [ ];\n\n    let lastStart = 0;\n    while (true) {\n        const nl = data.indexOf(10, lastStart);\n        if (nl === -1) { break; }\n        messages.push(data.subarray(lastStart, nl).toString().trim());\n        lastStart = nl + 1;\n    }\n\n    return { messages, remaining: data.subarray(lastStart) };\n}\n\nexport class IpcSocketProvider extends SocketProvider {\n    #socket: Socket;\n    get socket(): Socket { return this.#socket; }\n\n    constructor(path: string, network?: Networkish) {\n        super(network);\n        this.#socket = connect(path);\n\n        this.socket.on(\"ready\", async () => {\n            try {\n                await this._start();\n            } catch (error) {\n                console.log(\"failed to start IpcSocketProvider\", error);\n                // @TODO: Now what? Restart?\n            }\n        });\n\n        let response = Buffer.alloc(0);\n        this.socket.on(\"data\", (data) => {\n            response = Buffer.concat([ response, data ]);\n            const { messages, remaining } = splitBuffer(response);\n            messages.forEach((message) => {\n                this._processMessage(message);\n            });\n            response = remaining;\n        });\n\n        this.socket.on(\"end\", () => {\n            this.emit(\"close\");\n            this.socket.destroy();\n            this.socket.end();\n        });\n    }\n\n    destroy(): void {\n        this.socket.destroy();\n        this.socket.end();\n\n        super.destroy();\n    }\n\n    async _write(message: string): Promise<void> {\n        this.socket.write(message);\n    }\n}\n"],"mappings":";;;;;;AACA,MAAAA,KAAA,GAAAC,OAAA;AACA,MAAAC,oBAAA,GAAAD,OAAA;AAMA;AACA;AACA,SAASE,WAAWA,CAACC,IAAY;EAC7B,MAAMC,QAAQ,GAAkB,EAAG;EAEnC,IAAIC,SAAS,GAAG,CAAC;EACjB,OAAO,IAAI,EAAE;IACT,MAAMC,EAAE,GAAGH,IAAI,CAACI,OAAO,CAAC,EAAE,EAAEF,SAAS,CAAC;IACtC,IAAIC,EAAE,KAAK,CAAC,CAAC,EAAE;MAAE;;IACjBF,QAAQ,CAACI,IAAI,CAACL,IAAI,CAACM,QAAQ,CAACJ,SAAS,EAAEC,EAAE,CAAC,CAACI,QAAQ,EAAE,CAACC,IAAI,EAAE,CAAC;IAC7DN,SAAS,GAAGC,EAAE,GAAG,CAAC;;EAGtB,OAAO;IAAEF,QAAQ;IAAEQ,SAAS,EAAET,IAAI,CAACM,QAAQ,CAACJ,SAAS;EAAC,CAAE;AAC5D;AAEA,MAAaQ,iBAAkB,SAAQZ,oBAAA,CAAAa,cAAc;EACjD,CAAAC,MAAO;EACP,IAAIA,MAAMA,CAAA;IAAa,OAAO,IAAI,CAAC,CAAAA,MAAO;EAAE;EAE5CC,YAAYC,IAAY,EAAEC,OAAoB;IAC1C,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAAC,CAAAH,MAAO,GAAG,IAAAhB,KAAA,CAAAoB,OAAO,EAACF,IAAI,CAAC;IAE5B,IAAI,CAACF,MAAM,CAACK,EAAE,CAAC,OAAO,EAAE,YAAW;MAC/B,IAAI;QACA,MAAM,IAAI,CAACC,MAAM,EAAE;OACtB,CAAC,OAAOC,KAAK,EAAE;QACZC,OAAO,CAACC,GAAG,CAAC,mCAAmC,EAAEF,KAAK,CAAC;QACvD;;IAER,CAAC,CAAC;;IAEF,IAAIG,QAAQ,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IAC9B,IAAI,CAACZ,MAAM,CAACK,EAAE,CAAC,MAAM,EAAGjB,IAAI,IAAI;MAC5BsB,QAAQ,GAAGC,MAAM,CAACE,MAAM,CAAC,CAAEH,QAAQ,EAAEtB,IAAI,CAAE,CAAC;MAC5C,MAAM;QAAEC,QAAQ;QAAEQ;MAAS,CAAE,GAAGV,WAAW,CAACuB,QAAQ,CAAC;MACrDrB,QAAQ,CAACyB,OAAO,CAAEC,OAAO,IAAI;QACzB,IAAI,CAACC,eAAe,CAACD,OAAO,CAAC;MACjC,CAAC,CAAC;MACFL,QAAQ,GAAGb,SAAS;IACxB,CAAC,CAAC;IAEF,IAAI,CAACG,MAAM,CAACK,EAAE,CAAC,KAAK,EAAE,MAAK;MACvB,IAAI,CAACY,IAAI,CAAC,OAAO,CAAC;MAClB,IAAI,CAACjB,MAAM,CAACkB,OAAO,EAAE;MACrB,IAAI,CAAClB,MAAM,CAACmB,GAAG,EAAE;IACrB,CAAC,CAAC;EACN;EAEAD,OAAOA,CAAA;IACH,IAAI,CAAClB,MAAM,CAACkB,OAAO,EAAE;IACrB,IAAI,CAAClB,MAAM,CAACmB,GAAG,EAAE;IAEjB,KAAK,CAACD,OAAO,EAAE;EACnB;EAEA,MAAME,MAAMA,CAACL,OAAe;IACxB,IAAI,CAACf,MAAM,CAACqB,KAAK,CAACN,OAAO,CAAC;EAC9B;;AA3CJO,OAAA,CAAAxB,iBAAA,GAAAA,iBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}